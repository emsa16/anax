---
title: "Redovisningar"
...
Redovisningar
=============

Kursmoment 1
------------

### Gör din egen kunskapsinventering baserat på PHP The Right Way, berätta om dina styrkor och svagheter som du vill förstärka under det kommande året.
Detta var en intressant läsning då man får ett bra helhetsgrepp kring språket och dess olika verktyg och koncept. Den är dock lite ojämnt skriven då vissa sektioner är mycket mer utvecklade än andra, så jag kan inte vara helt säker på att den ger en helt objektivt korrekt överblick. Överlag så fick jag ändå ut mycket av den och jag skulle gärna läsa motsvarande artiklar för andra språk.

Vad kan jag då av detta? Ja, först av allt måste det sägas att även om jag här kommer att klassificera saker som något jag kan, så har jag fortfarande bara två kurser och projekt under bältet inom PHP, så det finns nog inget jag kan fullt ut. Men med det sagt så upplever jag ändå att följande områden behärskar jag någorlunda:

- **OOP**: jag har bra koll på konceptet i två språk nu (PHP och Python) och är bekväm med att programmera i denna paradigm, men det finns fortfarande många avancerade koncept som jag kunde utveckla mig på.
- **databasanvändning och PDO**
- **templates**: det har förekommit i flera kurser, så jag förstår det ganska bra som koncept nu, även om jag inte har koll på alla PHP-specifika template libraries.
- **kodstil**: När jag läser igenom PSR-standarderna så tycker jag att det ganska långt ser ut precis som den kod jag redan skriver.
- **namespaces**

Vad kan jag lite grann men behöver bli bättre på?

- **säkerhet**: jag har bra grunder men vill lära mig mer då detta är ett av de områden som jag funnit mest intressant i studierna.
- **functional programming**: jag vill kunna skapa smartare och mer effektiv kod.
- **tester**: jag kan grunden, men har det inte som en vana och tycker det känns jobbigt att skriva tester. Jag måste lära mig gilla det och lära mig mer avancerade metoder för att kunna testa kod som har dependencies, t.ex. av en databaskoppling.
- **dokumentation**: jag dokumenterar väldigt dåligt just nu och måste lära mig en vana att dokumentera bättre.
- **virtual machines**: vi har använt detta i en tidigare kurs, men jag behöver bli mer van med detta och speciellt bekanta mig med konceptet i PHP-sammanhang, inklusive Vagrant och Docker.
- **dependency injections**: jag kan grunderna, men ser framemot kursens fördjupning i ämnet.
- **dependency management**: jag fattar grunderna.
- **exception handling**: jag använder detta för lite.

Vad kan jag inte alls?

- **designmönster**: vi har bara nosat på det en gång tidigare i Javascript-kursen, men jag ser att flera av kursens referensböcker behandlar det ingående. Jag tycker att det är här programmering börjar bli intressant: olika programmeringsstilar och större konstruktionskoncept som sträcker sig över flera språk
- **build & deployment**: det här är den sista pusselbiten i webbprogrammering som jag upplever att vi inte riktigt gått igenom i någon kurs än så länge
- **continous integration**: jag ser framemot att lära mig om detta i kursen
- **internationalisering**
- **meta programming**: detta är i stort sätt ett helt nytt koncept för mig
- **caching**

Sammanfattningsvis så är de punkter jag främst skulle vilja lära mig och bli bättre på under det kommande året säkerhet, designmönster, deployment och functional programming.

### Vilket blev resultatet från din mini-undersökning om vilka ramverk som för närvarande är mest populära inom PHP (ange källa var du fann informationen)?
Jag kunde inte hitta någon artikel eller presentation av PHP-ramverk som verkade grunda sig på hårda data eller statistik. Jag har därför tittat på fem artiklar som alla påstår sig presentera de mest populära PHP-ramverken just nu, men endast vagt eller inte alls redogör för vad resultatet grundar sig på. Alla artiklar är från sommaren 2017 och hittas på följande länkar:

- [noeticforce.com](http://noeticforce.com/best-php-frameworks-for-modern-web-development)
- [Traversy Media](https://www.youtube.com/watch?v=Q84OlNsOGQY)
- [techjunkie.com](https://www.techjunkie.com/popular-php-frameworks/)
- [Elitech Systems](https://medium.com/@elitechsystems/the-most-popular-php-frameworks-in-2017-a90a1189405e)
- [codementor.io](https://www.codementor.io/sarahallenapp/7-most-popular-php-frameworks-of-2017-b8gyncyvv)

Vad jag gjort är att jag undersökt artiklarna kvantitativt och räknat i hur många av artiklarna ett ramverk nämns. Detta är kanske inte så vetenskapligt gångbart men som en enkel undersökning som ger ett hum om läget just nu så funkar den bra och det är för det mesta samma ramverk som återkommer. Tre ramverk nämns i alla fem artiklar och jag korar därför dem till sommaren 2017s populäraste ramverk:

- Laravel
- Symfony
- CodeIgniter

### Berätta om din syn/erfarenhet generellt kring communities och specifikt communities inom opensource och programmeringsdomänen.
Jag ser både stor potential och stora risker med communities, speciellt sådana som driver utvecklingen av t.ex. ett språk eller en teknik. Potentialen ligger i massans gemensamma intelligens, kapacitet och resurser, samt i den drivkraft som kan råda i ett community med en god kultur där en fin anda råder. Jag gillar också den demokratiska processen i den här typen av grupperingar, som ofta även ackompanjeras av ideella ideologier. Risken ligger dels i att communityt kommer att innehålla många individer som är starkt drivna av sin passion för ämnet, vilket lätt kan leda till konflikter. Och samtidigt som den demokratiska processen är en styrka så är den också en svaghet, då det kan vara svårt att ta effektiva beslut och ena communityt kring något. Eftersom det är frågan om ideellt arbete så finns också risken att gnistan dör, speciellt om communityt saknar eldsjälar. Det är alltså väldigt viktigt att man prioriterar och vårdar communitykulturen.

Jag har endast en utomståendes perspektiv på open source- & programmeringscommunities, då jag än så länge inte deltagit i några projekt, evenemang eller bekantat mig med användargrupper. På basen av videon som anvisades i kursmomentet så gav den dock en ganska mörk bild av PHP-communityt. Föreläsningens syfte var säkert att locka folk men jag kände bara olust att närma mig det communityt, som jag innan föreläsningen inte haft någon särskild uppfattning om. Det verkar som att PHP-communityt är väldigt stort och har lidit av stora problem tidigare, och ärligt talat så känner jag inte idag att jag har någon lust att beblanda mig med dem.

### Vad tror du om begreppet “en ramverkslös värld” som framfördes i videon?
Det är ju intressant att titeln på föreläsningen inte är vad innehållet sist och slutligen föreslår. Föreläsaren föreslår inte en framtid utan ramverk, utan en framtid där man ska kunna jobba mer modulärt och inte känna sig bunden till ett specifikt ramverk och alla dess delar och libraries. Detta kan jag absolut hålla med som en god princip att försöka hålla fast vid, det förvånar mig att det verkar som att många som arbetar med PHP identifierar sig inte som PHP-utvecklare utan t.ex. Laravel-utvecklare. Jag tycker att det finns en fara att köra in sig i ett ramverk för mycket, att man tappar flexibiltet och ett öppet sinne. Tankesättet att jobba modulärt, som är något vi kommer att fokusera på i kursen, ska bli spännande att utforska. Med detta sagt så tycker jag att det låter som en stor utmaning som PHP-FIG försöker lösa genom att skapa standarder för vissa moduler. Detta går dock lite över huvudet på min nuvarande kompetensnivå så jag lämnar det vid detta.

### Hur gick dina förberedelser inför kommentarssystemet?
Jag har inte skrivit någon kod utan endast skissat på papper än så länge. Jag har studerat kommentarsystemet på Stackoverflow och Reddit. Stackoverflow innehåller en del extra funktioner som inte hör till kärnfunktionaliteten för ett kommentarsystem, så jag har fokuserat mer på Reddit. Deras kommentarsystem är ganska enkelt att övergreppa och det finns många sidor som har liknande system, t.ex. Facebook, Twitter och Youtube. Jag har sedan brutit ner kommentarsystemet i mindre delar och planerat hur databasen skulle kunna se ut som ska lagra kommentarerna. Jag är inte säker ännu på hur jag ska strukturera upp det så att jag kan implementera kommentarsavdelningen som ett träd, alltså att man kan kommentera på en kommentar och därmed skapa grenar. Som jag ser det nu så kommer jag att behöva en databas för att lagra användare och kommentarer, en klass för att kommuncera med databasen, en klass för att hantera användare, en klass för sessioner och så en klass för att hantera nya kommentarer och kommentarsröstningar.



Kursmoment 02
-------------

### Allmänna reflektioner:
Jag är lite osäker på hur det är tänkt att vi ska strukturera om vår kod och är inte alls säker på om jag faktiskt delat upp min kod enligt MVC-mönstret. Jag hade tidigare en `Navbar`-klass, men då den endast hade en metod, som för det mesta bestod av HTML så har jag gjort om den till en vy och laddar in navbarens config-fil som data till navbaren direkt i `renderPage`-metoden. Jag har också flyttat ut all kod ur alla routes till en `RouterController`-klass. Denna känns dock lite klumpig och inte särskilt användbar, utan är bara en förflyttning av koden för att passa in i modellen, jag vinner ingenting på det vad jag kan se.

### Vilka tidigare erfarenheter har du av MVC? Använde du någon speciell källa för att läsa på om MVC? Kan du med egna ord förklara någon fördel med kontroller/modell-begreppet, så som du ser på det?
Vi nosade på begreppet i webapp-kursen, då Mithril använde sig MVC-mönstret. Jag skapade dock ingen egentlig förståelse för begreppet då, och såg därför framemot att sätta tänderna i det detta kursmoment. Jag har läst igenom det material som finns i läsanvisningarna flera gånger och har läst flera andra artiklar och ju mer jag läser, desto mer förvirrad blir jag. Det finns väldigt olika sätt att se på MVC-mönstret, så pass olika att jag har svårt att greppa konceptet ens på ett övergripande plan. [Denna artikel](https://blog.codinghorror.com/understanding-model-view-controller/) och [denna](https://www.sitepoint.com/the-mvc-pattern-and-php-1) ger egna versioner som båda skiljer sig väldigt mycket från det jag upplever att Wikipedia-artiklarna beskriver. Till slut fastnar jag för en mycket [kort artikel](https://www.tmprod.com/blog/2012/what-is-mvc-architecture-in-a-web-based-application) från läsanvisningarna i webapp-kursen, som hjälper mig att greppa koncepten på ett sätt som känns användbart.

Utifrån den läsning jag gjort så tolkar jag MVC som följande:

* **Kontroller**: navet i systemet (detta är min uppfattning, på Wikipedia anses modellen vara den centrala delen). Tar emot anrop och ber modellagret att hämta och bearbeta data beroende på anropet. Den behandlade datan skickas sedan till vyn för att läggas in i mallar. Den ifyllda vyn skickas sedan tillbaka till som svar på anropet. Kontrollern är alltså den kod som har kontroll över allt annat. Som jag ser det nu så måste en kontroller i Anax ha tillgång till app-objektet för att den ska kunna ge ordrar till en massa modellklasser. Detta gör dock att kontrollern är ganska hårt bunden till ramverket. Däremot har inte kontrollern så mycket egen logik utan bör vara ganska tunn, i alla fall upplever jag att koden blir bäst uppdelad så mellan kontroller och modell.
* **Modell**: Ett lager som innehåller alla möjliga typer av klasser, dels för att skapa kontakt med databaser och dels för att hantera data enligt kontrollerns order. Modellen är den som gör grovjobbet och har det mesta av logiken, men inte så mycket egen makt eller information om systemet på en global nivå. Jag tänker att modelllagret helst inte ska ha tillgång till app-objektet, framförallt för att modeller ska kunna göras modulära.
* **Vy**: tar emot data från kontrollern, lägger in den i HTML-mallar och bygger själva sidan. Vyn skickar därefter tillbaka den färdiga sidan till kontrollern.

Den här uppdelningen gör kontrollern till en ganska ointressant del, då den endast kallas andra metoder och funktioner, men det är kanske detta som är meningen. Dock har jag svårt att se var gränsen går mellan kontroller och modell, eftersom exempelvis Wikipedia-artiklarna mest fokuserar på separationen av vy och logik, vilket jag mycket väl förstår syftet med. I vissa artiklar omnämns kontrollern som att dess uppgift är att ha hand om input-logik, men jag tycker att det vore att förminska dess roll, i alla fall enligt det sätt jag ser på MVC.

Just nu ser jag den främsta fördelen med MVC att man kan göra modellklasserna löst kopplade och modulära. Jag tror också att en välbyggd MVC-applikation borde vara lätt att överse och underhålla.

### Kom du fram till vad begreppet SOLID innebar och vilka källor använde du? Kan du förklara SOLID på ett par rader med dina egna ord?
Jag har spenderat så mycket tid med att förstå MVC att SOLID-begreppet inte blivit så grundligt studerat. Jag har endast använt mig av kursmomentets anvisade material att förstå SOLID. På ett väldigt ytligt plan så är SOLID en samling designprinciper för objektorienterad design. Syftet med SOLID är att göra koden enklare att bygga, förstå och underhålla. Jag tycker att SOLID verkar som en väldigt viktig principsamling också när man vill göra sin kod så modulär som möjligt. Jag tycker att konceptet låter bra och intressant och jag ser framemot att kunna implementera det så snart som möjligt. Än så länge så är det dock väldigt svårt att minnas de enskilda principerna och även att förstå hur de konkret appliceras.

### Gick arbetet med REM servern bra och du lyckades integrera den i din me-sida?
Det gick väldigt enkelt att komma igång med REM-servern och att lyfta in den i me-sidan. Jag har gått den första versionen av webapp-kursen, så för mig är detta med REM-server helt nytt. Jag förstår inte riktigt varför det vi använder här kallas för REM-server. Jag hittar ingen information på nätet om det, förutom den tjänst som länkas till, men den tjänsten används ju inte i detta sammanhang. Jag blir också fundersam när jag ser `RemController` och `RemServer`, detta antyder att varje modellklass ska ha en egen kontrollerklass. Samtidigt rekommenderas man hålla kontrollerklassen liten. Hur många kontrollers är det tänkt man ska ha och hur delar man upp dem? Detta förblir oklart för mig, även om jag inte har svårt att använda systemen.

### Berätta om arbetet med din kommentarsmodul, hur långt har du kommit och hur tänker du?
Detta skulle vara en första prototyp och visst är det mycket funktionalitet som jag valt bort i detta skede, men särskilt enkelt blev det ändå inte. Det var mycket att fixa och fundera på. Jag har tittat mycket på [Hacker News](https://news.ycombinator.com/item?id=15254952) kommentarssystem, då deras gränssnitt är avskalat och fokuserat. Jag har lagt upp två inlägg som har ett kommentarssystem kopplat till sig. Kommentarerna är ordnade hierarkiskt så att en kommentar kan få egna svar och därmed skapar en förgrening. Jag har den underliggande strukturen för att implementera ett poängröstningssystem men har valt bort att implementera möjligheten att rösta i detta skede. En default-uppsättning med kommentarer ligger i en json-fil, som kan nås och bearbetas med REM-servern.

Jag har skapat en `Comment`-klass och en `CommentController`-klass för att hantera kommentarssystemet. I enlighet med mina tankar om MVC så ligger minimalt med logik i kontrollern, den anropar istället andra klasser och får tillbaka värden som sedan skickas vidare i nästa steg. I modellklassen ligger alla metoder som hanterar olika skeden av kommentarshanteringen. Vissa metoder är lite väl stora och kan förhoppnningsvis refaktoreras. Dessutom så hamnar en massa HTML-kod i modellen när jag bygger själva kommentarssektionen. Borde jag försöka lyfta ut detta i vyer? Det är tänkbart, men isåfall behöver jag kanske gå en annan väg än via `View`-modulen? En annan sak jag tvekar om är huruvida jag bör splitta upp koden i fler metoder för att göra dem tydligare och mer specifika, enligt single responsibility-principen, eller om jag bör försöka hålla koden så DRY som möjligt. Jag har gått fram och tillbaka mellan dessa under arbetets gång. Just nu känns framförallt metoden `buildCommentSection()` alltför stor och generell, men om jag bryter upp den i flera metoder så finns risken att jag upprepar mig, som är fallet lite grann med metoderna `buildNewCommentBox()` och `buildEditCommentBox()`.



Kursmoment 03
-------------

### Hur känns det att jobba med begreppen kring dependency injection, service locator och lazy loading?
De nya begreppen som introducerades detta kursmoment är ganska självförklarande och därför ganska lätta att ta till sig. Just på me-sidan kanske inte lazy loading har så stor betydelse men jag gillar konceptet. Det känns som en väldigt bra princip att inte ladda in något i onödan. Nu syns ju vilka paket man laddar in bara på `debug/info`-sidan, så variationen mellan vilka moduler som laddas in på olika sidor blir inte så visualiserad, men vetskapen om att så sker är rogivande. DI-begreppet innebär en klar förbättring av strukturen och gör delarna mer modulära och självständiga än tidigare.
Service locator-begreppet har jag dock lite svårare att greppa. Det verkar så likt dependency injection container att jag först tänker att det är samma sak, men vid mer efterforskning så verkar de vara två olika lösningar på samma problem, och service locator verkar även anses som ett dåligt mönster. Vad jag lyckats uttyda så verkar service locator innebära att klassen är beroende av denna service container, medan dependency injection innebär att beroenden skickas in till klassen helt och hållet utifrån så att klassen inte behöver veta något om detta.

### Hur känns det att göra dig av med beroendet till $app, blir $id bättre?
Jag tycker att koden blir redigare och bättre strukturerad med $di. Skillnaden är kanske inte direkt stor i och med att jag mest bara flyttat över $app-konceptet till $di. Jag uppskattar ändå config-filen di.php, då den är mycket mer överskådlig än den gamla service.php.

### Hur känns det att återigen göra refaktoring på din me-sida, blir det förbättringar på kodstrukturen, eller bara annorlunda?
Det var inte så omfattande arbete denna gång att refaktorera om till en sida med di-konstruktion. I mina egna klasser har jag bara bytt app mot di tack vare att jag använder mig av InjectionMagicTrait så att jag inte behöver ändra `$this->di->request` till `$this->di->get(”request”);`. Även om den senare tydligare visar att jag använder en di-konstruktion nu så är den förra mer lättläslig. Det nya sättet att skriva routes känns också tydligare. Istället för att ha allting i routen på en rad har de nya route-filerna en tydlig struktur genom arrayer med bestämda nyckelvärden. På det hela taget tycker jag att denna omgång av refaktorering kändes bra då den med små medel förtydligade mycket.

### Lyckades du införa begreppen kring DI när du vidareutvecklade ditt kommentarssystem?
Jag tror att jag infört begreppen kring DI i mitt kommentarssystem, men är lite osäker på vad omfattningen av DI kan innebära för mina klasser. Som jag nämnde ovan så bytte jag bara ut app mot di i min kontroller-klass. Min modellklass för kommentarssystemet har sedan tidigare ingen vetskap om $di, utan jag skickar in eventuella moduler som behövs genom argument direkt i metodanropet till modellklassen.

### Påbörjade du arbetet (hur gick det) med databasmodellen eller avvaktar du till kommande kmom?
Jag väljer att avvakta med databasen, eftersom jag inte vill börja fixa på en lösning om det ändå kommer att komma ytterligare instruktioner i nästa kursmoment. Jag har inte heller gjort så mycket mer på den nuvarande lösningen där jag sparar kommentarerna genom remservern, eftersom det ändå bara är en mockup inför den stundande databas-implementationen.

Jag har istället valt att lägga till en del småfunktionalitet som prioriterats bort i förra kursmomentet. Det går nu att sortera kommentarerna efter flest poäng, nyaste eller äldsta. Trädstrukturen följer sorteringsmetoden, i stil med Reddit. Sidan sorterar automatiskt på de bästa kommentarerna, vilket kanske inte blir så tydligt när mängden kommentarer är små, men får stor effekt på hur man kan följa intressanta kommentarskedjor när det finns många kommentarer och många som röstat.

Jag har även lagt in gränssnitt och funktionalitet för att kunna rösta upp och ner kommentarer. Eftersom det just nu inte finns användare implementerade så är möjligheten att rösta obegränsad. Vidare har jag ändrat beteendet för raderade kommentarer, istället för att ta bort dem rakt av så markeras kommentaren med en radera-flagga i systemet och texten syns inte i kommentarsfältet men noden blir kvar i hierarkin, istället för att hela den underliggande kedjan skulle tas bort tillsammans med den kommentar som raderas. Gränssnittet visar nu även när en kommentar senast redigerats. Tiden när en kommentar lagts till visar nu istället för ett datum en sträng i stilen ’x minuter sedan’.

`buildCommentSection`-metoden är fortfarande för stor och komplex, och validatorn har även klagat över cyclomatic complexity som stigit för högt i den. Jag har temporärt fixat detta med att ganska godtyckligt lyfta över en del kod i separata metoder, men det är inte gjort på ett bra sätt, så jag vill ännu justera detta.

### Allmänna kommentare kring din me-sida och dess kodstruktur?
Jag har nu valt att använda `\Anax\Page\PageRender()`-klassen i mitt ramverk, såsom artiklarna gjort. Detta är det mest logiska att använda när jag nu har modulen Page med och använder den i övrigt i mina routes. Dock kräver det att jag går in och justerar i `renderPage`-metoden för att få med header, navbar och footer. Detta känns inte så kul när denna klass ligger i min vendor-mapp och jag inte riktigt tycker om att gå in och ändra där. Det jag eventuellt kommer att göra är att återgå till att använda `renderPage`-metoden i min app-klass, eftersom den ligger i min egen src-mapp, och då känns det ok att rota mer i koden. Vi får se.



Kursmoment 04
-------------

### Hur gick det att integrera formulärhantering och databashantering i ditt kommentarssystem?
Jag valde att använda mig av de lösningar som LRC byggt med designmönstret Repository och även hans motsvarighet till HTMLForm-klasserna, istället för de moduler som angivits i kursmomentet. Efter att ha läst forumdiskussionerna om att de inte är så MVC-korrekta valde jag denna väg för att bättre förstå MVC och hur en modul som använder sig av MVC på ett strängare sätt fungerar. Detta blev början på en lång och svår resa och jag har spenderat otaliga timmar med att analysera den nya koden och förstå hur jag kan använda den. Jag ska inte sticka under stol med att jag tagit väldigt mycket från LRCs implementering, men jag vill ändå påstå att detta inneburit mer arbete än att scaffolda fram och flytta runt lite filer, då jag mödosamt byggt upp en ny struktur steg för steg.

Jag har blivit tvungen att göra om precis allt på mitt kommentarssystem, en refactoring som ändå behövde göras, men blev absolut nödvändigt med de nya modulerna. Jag hoppades på att kunna skapa en bättre och tydligare MVC-struktur. Ju mer tid detta tog desto mer måste jag ändå åter börja avvika från stränga principer och nu har jag igen en del metoder som är lite för yviga och en grumlig gräns mellan modell, kontroll och vy.

Jag inser nu att det finns vissa brister i de moduler jag valt att använda, eller troligen snarare i min förståelse för hur man använder dem. Allting känns mycket krångligare än någonsin förr och jag måste tänka igenom varenda steg otroligt länge för att inse vilken kod som ska användas, vilket känns som att det förstör syftet med att ha inkapslade moduler, där man ska ha ett begripligt gränssnitt att jobba mot. Även om koden må vara mer MVC-strukturerad så känns den mer begränsad och klumpig. Jag känner mig mer förvirrad än tidigare kring vilken kod som ska ligga i modeller och vilken i kontroller.

Ett exempel på problem är när en rad i databasen ska uppdateras: min Repository hämtar inlägget från databasen och samarbetar med ModelForm-klassen för att användaren ska kunna uppdatera informationen. Som Repository funkar nu så uppdateras alla celler i tabellraden, även om vissa kolumner inte ens finns med för klienten att justeras utan är ämnade att endast hanteras inifrån databasen, såsom en ’updated’-kolumn som endast reagerar när andra celler uppdateras, men som hela tiden blev överskriven med ett null-värde. Detta fick jag alltså gå in och ändra manuellt i koden på varje ställe det riskerade ske, vilket inte känns smidigt.

### Berätta om din syn på Active record och liknande upplägg, ser du fördelar och nackdelar?
Efter att ha jämfört och haft mig mellan kursmomentets moduler och LRCs Repository-förslag så har jag svårt att se vilken struktur som är bättre. Det är så många saker att hålla i huvudet och att försöka greppa flödet och strukturerna som helhet överstiger min förmåga. Jag började med en förhoppning om att bättre förstå MVC och jag kan se att det finns en skillnad i hur modulerna arbetar, men jag kan inte avgöra vilken som är bättre, det är för komplext.

### Utveckla din syn på koden du nu har i ramverket och din kommentars- och användarkod. Hur känns det?
Allting fungerar just nu, men det ser inte vackert ut under huven och känns inte MVC, inte bra. Jag bävar inför nästa moment där koden ska lyftas ut i en egen modul, den känns alltför hårt kopplad till resten av koden. Jag har försökt att tänka om kring vyerna, och tillåta mig lägga in villkorssatser och dylikt där, så länge som det endast har att göra med presentationen. Men nu känns vyerna svårlästa och en del av presentationen sker också i modell/kontroller.

### Om du vill, och har kunskap om, kan du även berätta om din syn på ORM och designmönstret Data Mapper som är närbesläktade med Active Record. Du kanske har erfarenhet av likande upplägg i andra sammanhang?
Så mycket tid har gått åt till att implementera Repository att jag inte har tid kvar att studera andra lösningar just nu.

### Vad tror du om begreppet scaffolding, kan det vara något att kika mer på?
Som nämnts så använde jag mig inte av scaffolding på min anax-sida då jag inte använde de moduler som det fanns scaffolding för. Visst kan jag se nyttan med scaffolding i sammanhang där man har en förutbestämd arkitektur och bara vill lägga till nya sidor/sektioner. Har man alltså ett ramverk där alla grundbultarna är på plats så är det bra, men är det något som ska ändras i grunden så blir scaffoldingen värdelös.



Kursmoment 05
-------------

### Hur gick arbetet med att lyfta ut koden ur me-sidan och placera i en egen modul?
Jag utgick ifrån scaffold-varianten ramverk1-module och flyttade över allt som hade med kommentarer att göra till min nya modul. Det kändes naturligt att välja kommentarsmodulen eftersom det är din vi arbetat med under kursens gång, även om den är rätt så problematisk som modul, framförallt för att den är beroende av ett flertal andra moduler, som inte är tillgängliga publikt. Det handlar främst om Form-klasserna, som används för att skapa formulär och koppla ihop kommentarsfunktionaliteten med Repository-modulen. Jag inkluderade även några vyer och content-filer i modulen, de får fungera som exempel på hur modulen kan användas.
Hela processen gick rätt så smidigt och det var enkelt att arbeta mot en lokal version av modulen genom att lägga en länk till comment-repot i vendor-mappen.

### Flöt det på bra med GitHub och kopplingen till Packagist?
Detta var den smidigaste delen av arbetet. Det var väldigt enkelt att först jobba mot dev-versionen av modulen på GitHub och att sedan lägga upp den på Packagist och bara ändra i composer.json.

### Hur gick det att åter installera modulen i din me-sida med composer, kunde du följa du din installationsmanual?
För att göra installationsprocessen så smidig som möjligt så valde jag att implementera den nya funktionalitetn som anax/di och anax/route erbjuder. Nu behöver jag inte gå in i config/di.php samt config/route.php och rota när modulen ska installeras utan kan rakt av kopiera över de modulspecifika filerna till en config/di-mapp respektive config/route-mapp. Efter detta kunde jag skapa ett enkelt bash-skript i comment-modulens script-mapp, som kopierar över allt som behövs till huvudrepot. I Anax-repots Makefile har jag lagt till ett target install-module module=emsa/comment som letar upp och exekverar skriptet.

Eftersom modulen har beroenden till klasser som endast ligger i min egen Anax-installation så har jag lagt till instruktioner för hur man kan dra ner en branch av min Anax som inte innehåller något av kommentarsfunktionaliteten. Det går enkelt att bara kopera alla de instruktioner som finns i README-filen rakt av och köra dem i terminalen. Dock så måste man fortfarande hantera databasen manuellt med att fylla i uppgifter om sin databasserver i config/database.php samt lägga till de tabeller som behövs med hjälp av de DDL-filer som erbjuds.

### Hur väl lyckas du enhetstesta din modul och hur mycket kodtäckning fick du med?
Detta blev den mest utmanande delen av detta kursmoment. Jag märkte att modulen egentligen är ganska dåligt ’modulariserad’ och har knepiga beroenden till andra klasser som ställde till det. Jag gjorde lite refactoring av koden, men det kunde inte lösa alla problem. Det knepiga är att Comment-modulen, som tidigare nämnt, är beroende av Form-klasser som ligger i min lokala Anax-installation. Att jag inte inkluderat denna funktionalitet direkt i Comment-modulen beror på att de används även av andra klasser i mitt Anax-repo. Varje kommentar har en användare kopplad till sig och klassen Comment är därför också beroende av min User-klass. Detta beror på att jag använder Repository för databashantering och för varje foreign key behöver jag ange vilken klass som hanterar den tabell som nyckeln pekar på. Jag skulle gärna försöka lösa detta genom att injecta User-klassen till Comment-klassen, men har ännu inte hittat ett bra tillvägagångssätt.

Det finns alltså en del klasser som behövs för att tester ska kunna köras på modulen. Jag har nu kopierat in dessa klasser i src-mappen i Comment-modulen. Detta är inte alls en lösning jag är nöjd med, men jag kunde i alla fall utesluta dessa extra klasser från att tas med i coverage-rapporten för modulen genom ett tillägg i .phpunit.xml. En framtida lösning skulle kunna vara att lägga upp dessa klasser som egna repon och sedan dra ner dem genom composer i vendor-mappen, men det löser egentligen inte det grundläggande problemet, som jag tror ligger djupt rotat i valet av Repository som databashanterare.

Eftersom Comment-modulen bara består av en CommentController- och en Comment-klass, så finns det rätt så lite som kan testas. De metoder som ligger i kontrollern som är callbacks för olika routrar är inte lämpliga att enhetstesta då de framförallt anropar andra klasser och bygger ihop ett svar på en HTTP-förfrågan, såsom kontroller ska göra i MVC-modellen. Comment-klassen innehåller en enda metod och den lyckas jag testa, samt två av kontrollerns hjälpmetoder. Jag lyckas därmed nå 26 % line coverage, men jag vet inte hur mycket mer jag kan få, i alla fall inte utan att göra seriös refactoring på kommentarsklasserna (vilket iofs kanske skulle behövas).

Sist och slutligen en kort kommentar om att det dyker upp några CodeSniffer-varningar för Comment-modulen på kod som även finns i Anax-repot (det gäller en Form-klass) där all kod passerar validering. Det verkar gälla olika regler i de olika repona, så jag väljer därför att ignorera dessa varningar.

### Några reflektioner över skillnaden med och utan modul?
Genom detta arbete har jag fått ytterligare förståelse för moduler och hur lätt hänt det är att man binder en klass rätt hårt. Jag tror att jag i större framtida projekt definitivt vill använda dessa metoder för att separera moduler från varandra och på det sättet tvinga fram en bättre kodstruktur, som är lättare att uppehålla och byta ut.



Kursmoment 06
-------------

### Har du någon erfarenhet av automatiserade testar och CI sedan tidigare?
Nej, allting som har med C*-flöden är nytt för mig, även om jag stött på begreppen några gånger under årens lopp. Det här med automatiserade tester är intressant, för i detta kursmoment har jag lagt mycket energi på att försöka skriva om koden och lägga till tester för att täcka så mycket som möjligt av koden, så det har inte känts så automatiserat den här veckan. Men nu när det jobbet är gjort så börjar väl det på riktigt automatiserade, att testerna körs varje gång jag gör en ny commit och byggtjänsterna snurrar igång.

### Hur ser du på begreppen, bra, onödigt, nödvändigt, tidskrävande?
C*-flöden är verkligen populärt just nu och hänger väl även ihop med trendbegreppet DevOps. Det är ett helt nytt universum med sina egna begrepp, metoder och verktyg så just nu känns det lite överväldigande att ta in det. Den omfattning som kursmomentet inneburit har dock varit greppbart och intressant. Jag tycker absolut att principen med CI är god och kan leda till bättre organisering och kod. Verktyg som gör kodanalys är också bra att ha till hands. Dock har jag tidigare märkt att när jag haft någon linter aktiv i Atom-miljön och lintern är överdrivet kritisk och listar en massa varningar att jag efter ett tag blir lite färgblind och slutar märka dem. Jag tycker att man inte ska utgå för mycket från kodanalysverktyg, eftersom de inte garanterar att koden är bra och effektiv. Samma sak gäller kodtäckning; har man hög kodtäckning är inte det en garanti för god kod, eftersom iaf PHPUnit verkar räknas utifrån statement coverage och inte exempelvis branch coverage som är en starkare form av coverage. Det blir då upp till en själv om man vill försöka nå detta, för det kommer inte att höja coverage-siffran. Har man istället låg kodtäckning så behöver det inte heller betyda att koden är dålig, utan bara att den är svårtestad, vilket givetvis kan vara ett problem men inte nödvändigtvis något som behöver åtgärdas, vilket jag kommer in på i nästa stycke.

### Hur stor kodtäckning lyckades du uppnå i din modul?
Jag har kämpat med refactoring på min kod men har inte lyckats bättre än att jag nått 32 % coverage. Jag vill ändå påstå att jag inte kan nå bättre täckning än så utan att gå in i de metoder i controllern som hanterar routes direkt och pysslar med redirects och vyer. Att försöka gå in och testa dessa metoder skulle kräva ett oerhört stort jobb med att mocka upp testmiljön. Dessutom så innehåller dessa otestade metoder ganska lite logik utan anropar mest andra moduler och metoder, såsom en god controller ska göra. Att testa dessa metoder skulle jag kategorisera som integrationstest snarare än enhetstest.
Jag har ändå gjort ganska många småjusteringar som jag är nöjd med och separerat olika delar av koden in i egna metoder som jag lyckats testa. Eftersom kodtäckningen inte är så imponerande så har jag istället lagt tid på att öka kodkvalitén enligt de externa verktyg som lagts till, mer om det i nästa stycke. Jag har även till slut förstått hur jag ska hantera de beroenden som mina klasser har när jag gör tester och har mockat upp en del stubbar som behövs för de tester som körs. Detta innebär att det enda externa beroende som finns för att köra tester är till anax/DI.
En sak som bekymrar mig med läget just nu är att nästan alla de metoder som jag just nu lyckas testa egentligen borde göras privata, eftersom de endast anropas inifrån samma klass. Skulle jag göra det så skulle min kodtäckning dock hamna på nära 0%. Därför har jag valt att behålla dem som publika metoder tills vidare.

### Berätta hur det gick att integrera mot de olika externa tjänsterna?
Det gick ganska smidigt. Dock behövde jag göra en del justeringar på grund av uppdateringar som skett sedan detta kursmoment släppts. CircleCI är numera i version 2.0 och deras konfigurationsfil är uppbyggd på ett annat sätt så det blev lite trial&error innan det fungerade som det skulle. Vidare så är PHPUnit 5 numera deprecated så jag behövde uppdatera den till version 6. Den versionen stödjer dock inte längre PHP 5.6 så jag måste uppdatera vilka versioner av PHP som Travis testar för att få grönt därifrån. Bara för att lära mig så valde jag att låta även CodeClimate visa kodtäckningen, vilket jag gjorde genom att koppla ihop den med Travis så att Travis skickar en rapport om kodtäckningen till CodeClimate när den är klar. Jag lade också till SensioLabs men deras tjänst är numera så låst bakom en betalvägg att den analysen inte gav något annat än en badge, jag kan inte se rapporten utan att betala för mig, så den tjänsten lär jag inte fortsätta använda.

### Vilken extern tjänst uppskattade du mest, eller har du förslag på ytterligare externa tjänster att använda?
Jag gillade CodeClimate ganska mycket. Även om den är rätt så snarlik Scrutinizer så tyckte jag att den var lite enklare att använda och ger tydligare rapporter om min kodkvalité, vilket jag uppskattar. Jag lyckades också rätta till en del brister i min kod tack vare den tjänsten och fick upp mitt betyg till ett A, så det är väl klart att man gillar sånt :)



Kursmoment 07/10
-------------
