---
title: "Redovisningar"
...
Redovisningar
=============

Kursmoment 1
------------

### Gör din egen kunskapsinventering baserat på PHP The Right Way, berätta om dina styrkor och svagheter som du vill förstärka under det kommande året.
Detta var en intressant läsning då man får ett bra helhetsgrepp kring språket och dess olika verktyg och koncept. Den är dock lite ojämnt skriven då vissa sektioner är mycket mer utvecklade än andra, så jag kan inte vara helt säker på att den ger en helt objektivt korrekt överblick. Överlag så fick jag ändå ut mycket av den och jag skulle gärna läsa motsvarande artiklar för andra språk.

Vad kan jag då av detta? Ja, först av allt måste det sägas att även om jag här kommer att klassificera saker som något jag kan, så har jag fortfarande bara två kurser och projekt under bältet inom PHP, så det finns nog inget jag kan fullt ut. Men med det sagt så upplever jag ändå att följande områden behärskar jag någorlunda:

- **OOP**: jag har bra koll på konceptet i två språk nu (PHP och Python) och är bekväm med att programmera i denna paradigm, men det finns fortfarande många avancerade koncept som jag kunde utveckla mig på.
- **databasanvändning och PDO**
- **templates**: det har förekommit i flera kurser, så jag förstår det ganska bra som koncept nu, även om jag inte har koll på alla PHP-specifika template libraries.
- **kodstil**: När jag läser igenom PSR-standarderna så tycker jag att det ganska långt ser ut precis som den kod jag redan skriver.
- **namespaces**

Vad kan jag lite grann men behöver bli bättre på?

- **säkerhet**: jag har bra grunder men vill lära mig mer då detta är ett av de områden som jag funnit mest intressant i studierna.
- **functional programming**: jag vill kunna skapa smartare och mer effektiv kod.
- **tester**: jag kan grunden, men har det inte som en vana och tycker det känns jobbigt att skriva tester. Jag måste lära mig gilla det och lära mig mer avancerade metoder för att kunna testa kod som har dependencies, t.ex. av en databaskoppling.
- **dokumentation**: jag dokumenterar väldigt dåligt just nu och måste lära mig en vana att dokumentera bättre.
- **virtual machines**: vi har använt detta i en tidigare kurs, men jag behöver bli mer van med detta och speciellt bekanta mig med konceptet i PHP-sammanhang, inklusive Vagrant och Docker.
- **dependency injections**: jag kan grunderna, men ser framemot kursens fördjupning i ämnet.
- **dependency management**: jag fattar grunderna.
- **exception handling**: jag använder detta för lite.

Vad kan jag inte alls?

- **designmönster**: vi har bara nosat på det en gång tidigare i Javascript-kursen, men jag ser att flera av kursens referensböcker behandlar det ingående. Jag tycker att det är här programmering börjar bli intressant: olika programmeringsstilar och större konstruktionskoncept som sträcker sig över flera språk
- **build & deployment**: det här är den sista pusselbiten i webbprogrammering som jag upplever att vi inte riktigt gått igenom i någon kurs än så länge
- **continous integration**: jag ser framemot att lära mig om detta i kursen
- **internationalisering**
- **meta programming**: detta är i stort sätt ett helt nytt koncept för mig
- **caching**

Sammanfattningsvis så är de punkter jag främst skulle vilja lära mig och bli bättre på under det kommande året säkerhet, designmönster, deployment och functional programming.

### Vilket blev resultatet från din mini-undersökning om vilka ramverk som för närvarande är mest populära inom PHP (ange källa var du fann informationen)?
Jag kunde inte hitta någon artikel eller presentation av PHP-ramverk som verkade grunda sig på hårda data eller statistik. Jag har därför tittat på fem artiklar som alla påstår sig presentera de mest populära PHP-ramverken just nu, men endast vagt eller inte alls redogör för vad resultatet grundar sig på. Alla artiklar är från sommaren 2017 och hittas på följande länkar:

- [noeticforce.com](http://noeticforce.com/best-php-frameworks-for-modern-web-development)
- [Traversy Media](https://www.youtube.com/watch?v=Q84OlNsOGQY)
- [techjunkie.com](https://www.techjunkie.com/popular-php-frameworks/)
- [Elitech Systems](https://medium.com/@elitechsystems/the-most-popular-php-frameworks-in-2017-a90a1189405e)
- [codementor.io](https://www.codementor.io/sarahallenapp/7-most-popular-php-frameworks-of-2017-b8gyncyvv)

Vad jag gjort är att jag undersökt artiklarna kvantitativt och räknat i hur många av artiklarna ett ramverk nämns. Detta är kanske inte så vetenskapligt gångbart men som en enkel undersökning som ger ett hum om läget just nu så funkar den bra och det är för det mesta samma ramverk som återkommer. Tre ramverk nämns i alla fem artiklar och jag korar därför dem till sommaren 2017s populäraste ramverk:

- Laravel
- Symfony
- CodeIgniter

### Berätta om din syn/erfarenhet generellt kring communities och specifikt communities inom opensource och programmeringsdomänen.
Jag ser både stor potential och stora risker med communities, speciellt sådana som driver utvecklingen av t.ex. ett språk eller en teknik. Potentialen ligger i massans gemensamma intelligens, kapacitet och resurser, samt i den drivkraft som kan råda i ett community med en god kultur där en fin anda råder. Jag gillar också den demokratiska processen i den här typen av grupperingar, som ofta även ackompanjeras av ideella ideologier. Risken ligger dels i att communityt kommer att innehålla många individer som är starkt drivna av sin passion för ämnet, vilket lätt kan leda till konflikter. Och samtidigt som den demokratiska processen är en styrka så är den också en svaghet, då det kan vara svårt att ta effektiva beslut och ena communityt kring något. Eftersom det är frågan om ideellt arbete så finns också risken att gnistan dör, speciellt om communityt saknar eldsjälar. Det är alltså väldigt viktigt att man prioriterar och vårdar communitykulturen.

Jag har endast en utomståendes perspektiv på open source- & programmeringscommunities, då jag än så länge inte deltagit i några projekt, evenemang eller bekantat mig med användargrupper. På basen av videon som anvisades i kursmomentet så gav den dock en ganska mörk bild av PHP-communityt. Föreläsningens syfte var säkert att locka folk men jag kände bara olust att närma mig det communityt, som jag innan föreläsningen inte haft någon särskild uppfattning om. Det verkar som att PHP-communityt är väldigt stort och har lidit av stora problem tidigare, och ärligt talat så känner jag inte idag att jag har någon lust att beblanda mig med dem.

### Vad tror du om begreppet “en ramverkslös värld” som framfördes i videon?
Det är ju intressant att titeln på föreläsningen inte är vad innehållet sist och slutligen föreslår. Föreläsaren föreslår inte en framtid utan ramverk, utan en framtid där man ska kunna jobba mer modulärt och inte känna sig bunden till ett specifikt ramverk och alla dess delar och libraries. Detta kan jag absolut hålla med som en god princip att försöka hålla fast vid, det förvånar mig att det verkar som att många som arbetar med PHP identifierar sig inte som PHP-utvecklare utan t.ex. Laravel-utvecklare. Jag tycker att det finns en fara att köra in sig i ett ramverk för mycket, att man tappar flexibiltet och ett öppet sinne. Tankesättet att jobba modulärt, som är något vi kommer att fokusera på i kursen, ska bli spännande att utforska. Med detta sagt så tycker jag att det låter som en stor utmaning som PHP-FIG försöker lösa genom att skapa standarder för vissa moduler. Detta går dock lite över huvudet på min nuvarande kompetensnivå så jag lämnar det vid detta.

### Hur gick dina förberedelser inför kommentarssystemet?
Jag har inte skrivit någon kod utan endast skissat på papper än så länge. Jag har studerat kommentarsystemet på Stackoverflow och Reddit. Stackoverflow innehåller en del extra funktioner som inte hör till kärnfunktionaliteten för ett kommentarsystem, så jag har fokuserat mer på Reddit. Deras kommentarsystem är ganska enkelt att övergreppa och det finns många sidor som har liknande system, t.ex. Facebook, Twitter och Youtube. Jag har sedan brutit ner kommentarsystemet i mindre delar och planerat hur databasen skulle kunna se ut som ska lagra kommentarerna. Jag är inte säker ännu på hur jag ska strukturera upp det så att jag kan implementera kommentarsavdelningen som ett träd, alltså att man kan kommentera på en kommentar och därmed skapa grenar. Som jag ser det nu så kommer jag att behöva en databas för att lagra användare och kommentarer, en klass för att kommuncera med databasen, en klass för att hantera användare, en klass för sessioner och så en klass för att hantera nya kommentarer och kommentarsröstningar.



Kursmoment 02
-------------

### Allmänna reflektioner:
Jag är lite osäker på hur det är tänkt att vi ska strukturera om vår kod och är inte alls säker på om jag faktiskt delat upp min kod enligt MVC-mönstret. Jag hade tidigare en `Navbar`-klass, men då den endast hade en metod, som för det mesta bestod av HTML så har jag gjort om den till en vy och laddar in navbarens config-fil som data till navbaren direkt i `renderPage`-metoden. Jag har också flyttat ut all kod ur alla routes till en `RouterController`-klass. Denna känns dock lite klumpig och inte särskilt användbar, utan är bara en förflyttning av koden för att passa in i modellen, jag vinner ingenting på det vad jag kan se.

### Vilka tidigare erfarenheter har du av MVC? Använde du någon speciell källa för att läsa på om MVC? Kan du med egna ord förklara någon fördel med kontroller/modell-begreppet, så som du ser på det?
Vi nosade på begreppet i webapp-kursen, då Mithril använde sig MVC-mönstret. Jag skapade dock ingen egentlig förståelse för begreppet då, och såg därför framemot att sätta tänderna i det detta kursmoment. Jag har läst igenom det material som finns i läsanvisningarna flera gånger och har läst flera andra artiklar och ju mer jag läser, desto mer förvirrad blir jag. Det finns väldigt olika sätt att se på MVC-mönstret, så pass olika att jag har svårt att greppa konceptet ens på ett övergripande plan. [Denna artikel](https://blog.codinghorror.com/understanding-model-view-controller/) och [denna](https://www.sitepoint.com/the-mvc-pattern-and-php-1) ger egna versioner som båda skiljer sig väldigt mycket från det jag upplever att Wikipedia-artiklarna beskriver. Till slut fastnar jag för en mycket [kort artikel](https://www.tmprod.com/blog/2012/what-is-mvc-architecture-in-a-web-based-application) från läsanvisningarna i webapp-kursen, som hjälper mig att greppa koncepten på ett sätt som känns användbart.

Utifrån den läsning jag gjort så tolkar jag MVC som följande:

* **Kontroller**: navet i systemet (detta är min uppfattning, på Wikipedia anses modellen vara den centrala delen). Tar emot anrop och ber modellagret att hämta och bearbeta data beroende på anropet. Den behandlade datan skickas sedan till vyn för att läggas in i mallar. Den ifyllda vyn skickas sedan tillbaka till som svar på anropet. Kontrollern är alltså den kod som har kontroll över allt annat. Som jag ser det nu så måste en kontroller i Anax ha tillgång till app-objektet för att den ska kunna ge ordrar till en massa modellklasser. Detta gör dock att kontrollern är ganska hårt bunden till ramverket. Däremot har inte kontrollern så mycket egen logik utan bör vara ganska tunn, i alla fall upplever jag att koden blir bäst uppdelad så mellan kontroller och modell.
* **Modell**: Ett lager som innehåller alla möjliga typer av klasser, dels för att skapa kontakt med databaser och dels för att hantera data enligt kontrollerns order. Modellen är den som gör grovjobbet och har det mesta av logiken, men inte så mycket egen makt eller information om systemet på en global nivå. Jag tänker att modelllagret helst inte ska ha tillgång till app-objektet, framförallt för att modeller ska kunna göras modulära.
* **Vy**: tar emot data från kontrollern, lägger in den i HTML-mallar och bygger själva sidan. Vyn skickar därefter tillbaka den färdiga sidan till kontrollern.

Den här uppdelningen gör kontrollern till en ganska ointressant del, då den endast kallas andra metoder och funktioner, men det är kanske detta som är meningen. Dock har jag svårt att se var gränsen går mellan kontroller och modell, eftersom exempelvis Wikipedia-artiklarna mest fokuserar på separationen av vy och logik, vilket jag mycket väl förstår syftet med. I vissa artiklar omnämns kontrollern som att dess uppgift är att ha hand om input-logik, men jag tycker att det vore att förminska dess roll, i alla fall enligt det sätt jag ser på MVC.

Just nu ser jag den främsta fördelen med MVC att man kan göra modellklasserna löst kopplade och modulära. Jag tror också att en välbyggd MVC-applikation borde vara lätt att överse och underhålla.

### Kom du fram till vad begreppet SOLID innebar och vilka källor använde du? Kan du förklara SOLID på ett par rader med dina egna ord?
Jag har spenderat så mycket tid med att förstå MVC att SOLID-begreppet inte blivit så grundligt studerat. Jag har endast använt mig av kursmomentets anvisade material att förstå SOLID. På ett väldigt ytligt plan så är SOLID en samling designprinciper för objektorienterad design. Syftet med SOLID är att göra koden enklare att bygga, förstå och underhålla. Jag tycker att SOLID verkar som en väldigt viktig principsamling också när man vill göra sin kod så modulär som möjligt. Jag tycker att konceptet låter bra och intressant och jag ser framemot att kunna implementera det så snart som möjligt. Än så länge så är det dock väldigt svårt att minnas de enskilda principerna och även att förstå hur de konkret appliceras.

### Gick arbetet med REM servern bra och du lyckades integrera den i din me-sida?
Det gick väldigt enkelt att komma igång med REM-servern och att lyfta in den i me-sidan. Jag har gått den första versionen av webapp-kursen, så för mig är detta med REM-server helt nytt. Jag förstår inte riktigt varför det vi använder här kallas för REM-server. Jag hittar ingen information på nätet om det, förutom den tjänst som länkas till, men den tjänsten används ju inte i detta sammanhang. Jag blir också fundersam när jag ser `RemController` och `RemServer`, detta antyder att varje modellklass ska ha en egen kontrollerklass. Samtidigt rekommenderas man hålla kontrollerklassen liten. Hur många kontrollers är det tänkt man ska ha och hur delar man upp dem? Detta förblir oklart för mig, även om jag inte har svårt att använda systemen.

### Berätta om arbetet med din kommentarsmodul, hur långt har du kommit och hur tänker du?
Detta skulle vara en första prototyp och visst är det mycket funktionalitet som jag valt bort i detta skede, men särskilt enkelt blev det ändå inte. Det var mycket att fixa och fundera på. Jag har tittat mycket på [Hacker News](https://news.ycombinator.com/item?id=15254952) kommentarssystem, då deras gränssnitt är avskalat och fokuserat. Jag har lagt upp två inlägg som har ett kommentarssystem kopplat till sig. Kommentarerna är ordnade hierarkiskt så att en kommentar kan få egna svar och därmed skapar en förgrening. Jag har den underliggande strukturen för att implementera ett poängröstningssystem men har valt bort att implementera möjligheten att rösta i detta skede. En default-uppsättning med kommentarer ligger i en json-fil, som kan nås och bearbetas med REM-servern.

Jag har skapat en `Comment`-klass och en `CommentController`-klass för att hantera kommentarssystemet. I enlighet med mina tankar om MVC så ligger minimalt med logik i kontrollern, den anropar istället andra klasser och får tillbaka värden som sedan skickas vidare i nästa steg. I modellklassen ligger alla metoder som hanterar olika skeden av kommentarshanteringen. Vissa metoder är lite väl stora och kan förhoppnningsvis refaktoreras. Dessutom så hamnar en massa HTML-kod i modellen när jag bygger själva kommentarssektionen. Borde jag försöka lyfta ut detta i vyer? Det är tänkbart, men isåfall behöver jag kanske gå en annan väg än via `View`-modulen? En annan sak jag tvekar om är huruvida jag bör splitta upp koden i fler metoder för att göra dem tydligare och mer specifika, enligt single responsibility-principen, eller om jag bör försöka hålla koden så DRY som möjligt. Jag har gått fram och tillbaka mellan dessa under arbetets gång. Just nu känns framförallt metoden `buildCommentSection()` alltför stor och generell, men om jag bryter upp den i flera metoder så finns risken att jag upprepar mig, som är fallet lite grann med metoderna `buildNewCommentBox()` och `buildEditCommentBox()`.



Kursmoment 03
-------------

### Hur känns det att jobba med begreppen kring dependency injection, service locator och lazy loading?
De nya begreppen som introducerades detta kursmoment är ganska självförklarande och därför ganska lätta att ta till sig. Just på me-sidan kanske inte lazy loading har så stor betydelse men jag gillar konceptet. Det känns som en väldigt bra princip att inte ladda in något i onödan. Nu syns ju vilka paket man laddar in bara på `debug/info`-sidan, så variationen mellan vilka moduler som laddas in på olika sidor blir inte så visualiserad, men vetskapen om att så sker är rogivande. DI-begreppet innebär en klar förbättring av strukturen och gör delarna mer modulära och självständiga än tidigare.
Service locator-begreppet har jag dock lite svårare att greppa. Det verkar så likt dependency injection container att jag först tänker att det är samma sak, men vid mer efterforskning så verkar de vara två olika lösningar på samma problem, och service locator verkar även anses som ett dåligt mönster. Vad jag lyckats uttyda så verkar service locator innebära att klassen är beroende av denna service container, medan dependency injection innebär att beroenden skickas in till klassen helt och hållet utifrån så att klassen inte behöver veta något om detta.

### Hur känns det att göra dig av med beroendet till $app, blir $id bättre?
Jag tycker att koden blir redigare och bättre strukturerad med $di. Skillnaden är kanske inte direkt stor i och med att jag mest bara flyttat över $app-konceptet till $di. Jag uppskattar ändå config-filen di.php, då den är mycket mer överskådlig än den gamla service.php.

### Hur känns det att återigen göra refaktoring på din me-sida, blir det förbättringar på kodstrukturen, eller bara annorlunda?
Det var inte så omfattande arbete denna gång att refaktorera om till en sida med di-konstruktion. I mina egna klasser har jag bara bytt app mot di tack vare att jag använder mig av InjectionMagicTrait så att jag inte behöver ändra `$this->di->request` till `$this->di->get(”request”);`. Även om den senare tydligare visar att jag använder en di-konstruktion nu så är den förra mer lättläslig. Det nya sättet att skriva routes känns också tydligare. Istället för att ha allting i routen på en rad har de nya route-filerna en tydlig struktur genom arrayer med bestämda nyckelvärden. På det hela taget tycker jag att denna omgång av refaktorering kändes bra då den med små medel förtydligade mycket.

### Lyckades du införa begreppen kring DI när du vidareutvecklade ditt kommentarssystem?
Jag tror att jag infört begreppen kring DI i mitt kommentarssystem, men är lite osäker på vad omfattningen av DI kan innebära för mina klasser. Som jag nämnde ovan så bytte jag bara ut app mot di i min kontroller-klass. Min modellklass för kommentarssystemet har sedan tidigare ingen vetskap om $di, utan jag skickar in eventuella moduler som behövs genom argument direkt i metodanropet till modellklassen.

### Påbörjade du arbetet (hur gick det) med databasmodellen eller avvaktar du till kommande kmom?
Jag väljer att avvakta med databasen, eftersom jag inte vill börja fixa på en lösning om det ändå kommer att komma ytterligare instruktioner i nästa kursmoment. Jag har inte heller gjort så mycket mer på den nuvarande lösningen där jag sparar kommentarerna genom remservern, eftersom det ändå bara är en mockup inför den stundande databas-implementationen.

Jag har istället valt att lägga till en del småfunktionalitet som prioriterats bort i förra kursmomentet. Det går nu att sortera kommentarerna efter flest poäng, nyaste eller äldsta. Trädstrukturen följer sorteringsmetoden, i stil med Reddit. Sidan sorterar automatiskt på de bästa kommentarerna, vilket kanske inte blir så tydligt när mängden kommentarer är små, men får stor effekt på hur man kan följa intressanta kommentarskedjor när det finns många kommentarer och många som röstat.

Jag har även lagt in gränssnitt och funktionalitet för att kunna rösta upp och ner kommentarer. Eftersom det just nu inte finns användare implementerade så är möjligheten att rösta obegränsad. Vidare har jag ändrat beteendet för raderade kommentarer, istället för att ta bort dem rakt av så markeras kommentaren med en radera-flagga i systemet och texten syns inte i kommentarsfältet men noden blir kvar i hierarkin, istället för att hela den underliggande kedjan skulle tas bort tillsammans med den kommentar som raderas. Gränssnittet visar nu även när en kommentar senast redigerats. Tiden när en kommentar lagts till visar nu istället för ett datum en sträng i stilen ’x minuter sedan’.

`buildCommentSection`-metoden är fortfarande för stor och komplex, och validatorn har även klagat över cyclomatic complexity som stigit för högt i den. Jag har temporärt fixat detta med att ganska godtyckligt lyfta över en del kod i separata metoder, men det är inte gjort på ett bra sätt, så jag vill ännu justera detta.

### Allmänna kommentare kring din me-sida och dess kodstruktur?
Jag har nu valt att använda `\Anax\Page\PageRender()`-klassen i mitt ramverk, såsom artiklarna gjort. Detta är det mest logiska att använda när jag nu har modulen Page med och använder den i övrigt i mina routes. Dock kräver det att jag går in och justerar i `renderPage`-metoden för att få med header, navbar och footer. Detta känns inte så kul när denna klass ligger i min vendor-mapp och jag inte riktigt tycker om att gå in och ändra där. Det jag eventuellt kommer att göra är att återgå till att använda `renderPage`-metoden i min app-klass, eftersom den ligger i min egen src-mapp, och då känns det ok att rota mer i koden. Vi får se.



Kursmoment 04
-------------

### Hur gick det att integrera formulärhantering och databashantering i ditt kommentarssystem?
Jag valde att använda mig av de lösningar som LRC byggt med designmönstret Repository och även hans motsvarighet till HTMLForm-klasserna, istället för de moduler som angivits i kursmomentet. Efter att ha läst forumdiskussionerna om att de inte är så MVC-korrekta valde jag denna väg för att bättre förstå MVC och hur en modul som använder sig av MVC på ett strängare sätt fungerar. Detta blev början på en lång och svår resa och jag har spenderat otaliga timmar med att analysera den nya koden och förstå hur jag kan använda den. Jag ska inte sticka under stol med att jag tagit väldigt mycket från LRCs implementering, men jag vill ändå påstå att detta inneburit mer arbete än att scaffolda fram och flytta runt lite filer, då jag mödosamt byggt upp en ny struktur steg för steg.

Jag har blivit tvungen att göra om precis allt på mitt kommentarssystem, en refactoring som ändå behövde göras, men blev absolut nödvändigt med de nya modulerna. Jag hoppades på att kunna skapa en bättre och tydligare MVC-struktur. Ju mer tid detta tog desto mer måste jag ändå åter börja avvika från stränga principer och nu har jag igen en del metoder som är lite för yviga och en grumlig gräns mellan modell, kontroll och vy.

Jag inser nu att det finns vissa brister i de moduler jag valt att använda, eller troligen snarare i min förståelse för hur man använder dem. Allting känns mycket krångligare än någonsin förr och jag måste tänka igenom varenda steg otroligt länge för att inse vilken kod som ska användas, vilket känns som att det förstör syftet med att ha inkapslade moduler, där man ska ha ett begripligt gränssnitt att jobba mot. Även om koden må vara mer MVC-strukturerad så känns den mer begränsad och klumpig. Jag känner mig mer förvirrad än tidigare kring vilken kod som ska ligga i modeller och vilken i kontroller.

Ett exempel på problem är när en rad i databasen ska uppdateras: min Repository hämtar inlägget från databasen och samarbetar med ModelForm-klassen för att användaren ska kunna uppdatera informationen. Som Repository funkar nu så uppdateras alla celler i tabellraden, även om vissa kolumner inte ens finns med för klienten att justeras utan är ämnade att endast hanteras inifrån databasen, såsom en ’updated’-kolumn som endast reagerar när andra celler uppdateras, men som hela tiden blev överskriven med ett null-värde. Detta fick jag alltså gå in och ändra manuellt i koden på varje ställe det riskerade ske, vilket inte känns smidigt.

### Berätta om din syn på Active record och liknande upplägg, ser du fördelar och nackdelar?
Efter att ha jämfört och haft mig mellan kursmomentets moduler och LRCs Repository-förslag så har jag svårt att se vilken struktur som är bättre. Det är så många saker att hålla i huvudet och att försöka greppa flödet och strukturerna som helhet överstiger min förmåga. Jag började med en förhoppning om att bättre förstå MVC och jag kan se att det finns en skillnad i hur modulerna arbetar, men jag kan inte avgöra vilken som är bättre, det är för komplext.

### Utveckla din syn på koden du nu har i ramverket och din kommentars- och användarkod. Hur känns det?
Allting fungerar just nu, men det ser inte vackert ut under huven och känns inte MVC, inte bra. Jag bävar inför nästa moment där koden ska lyftas ut i en egen modul, den känns alltför hårt kopplad till resten av koden. Jag har försökt att tänka om kring vyerna, och tillåta mig lägga in villkorssatser och dylikt där, så länge som det endast har att göra med presentationen. Men nu känns vyerna svårlästa och en del av presentationen sker också i modell/kontroller.

### Om du vill, och har kunskap om, kan du även berätta om din syn på ORM och designmönstret Data Mapper som är närbesläktade med Active Record. Du kanske har erfarenhet av likande upplägg i andra sammanhang?
Så mycket tid har gått åt till att implementera Repository att jag inte har tid kvar att studera andra lösningar just nu.

### Vad tror du om begreppet scaffolding, kan det vara något att kika mer på?
Som nämnts så använde jag mig inte av scaffolding på min anax-sida då jag inte använde de moduler som det fanns scaffolding för. Visst kan jag se nyttan med scaffolding i sammanhang där man har en förutbestämd arkitektur och bara vill lägga till nya sidor/sektioner. Har man alltså ett ramverk där alla grundbultarna är på plats så är det bra, men är det något som ska ändras i grunden så blir scaffoldingen värdelös.



Kursmoment 05
-------------

### Hur gick arbetet med att lyfta ut koden ur me-sidan och placera i en egen modul?
Jag utgick ifrån scaffold-varianten ramverk1-module och flyttade över allt som hade med kommentarer att göra till min nya modul. Det kändes naturligt att välja kommentarsmodulen eftersom det är din vi arbetat med under kursens gång, även om den är rätt så problematisk som modul, framförallt för att den är beroende av ett flertal andra moduler, som inte är tillgängliga publikt. Det handlar främst om Form-klasserna, som används för att skapa formulär och koppla ihop kommentarsfunktionaliteten med Repository-modulen. Jag inkluderade även några vyer och content-filer i modulen, de får fungera som exempel på hur modulen kan användas.
Hela processen gick rätt så smidigt och det var enkelt att arbeta mot en lokal version av modulen genom att lägga en länk till comment-repot i vendor-mappen.

### Flöt det på bra med GitHub och kopplingen till Packagist?
Detta var den smidigaste delen av arbetet. Det var väldigt enkelt att först jobba mot dev-versionen av modulen på GitHub och att sedan lägga upp den på Packagist och bara ändra i composer.json.

### Hur gick det att åter installera modulen i din me-sida med composer, kunde du följa du din installationsmanual?
För att göra installationsprocessen så smidig som möjligt så valde jag att implementera den nya funktionalitetn som anax/di och anax/route erbjuder. Nu behöver jag inte gå in i config/di.php samt config/route.php och rota när modulen ska installeras utan kan rakt av kopiera över de modulspecifika filerna till en config/di-mapp respektive config/route-mapp. Efter detta kunde jag skapa ett enkelt bash-skript i comment-modulens script-mapp, som kopierar över allt som behövs till huvudrepot. I Anax-repots Makefile har jag lagt till ett target install-module module=emsa/comment som letar upp och exekverar skriptet.

Eftersom modulen har beroenden till klasser som endast ligger i min egen Anax-installation så har jag lagt till instruktioner för hur man kan dra ner en branch av min Anax som inte innehåller något av kommentarsfunktionaliteten. Det går enkelt att bara kopera alla de instruktioner som finns i README-filen rakt av och köra dem i terminalen. Dock så måste man fortfarande hantera databasen manuellt med att fylla i uppgifter om sin databasserver i config/database.php samt lägga till de tabeller som behövs med hjälp av de DDL-filer som erbjuds.

### Hur väl lyckas du enhetstesta din modul och hur mycket kodtäckning fick du med?
Detta blev den mest utmanande delen av detta kursmoment. Jag märkte att modulen egentligen är ganska dåligt ’modulariserad’ och har knepiga beroenden till andra klasser som ställde till det. Jag gjorde lite refactoring av koden, men det kunde inte lösa alla problem. Det knepiga är att Comment-modulen, som tidigare nämnt, är beroende av Form-klasser som ligger i min lokala Anax-installation. Att jag inte inkluderat denna funktionalitet direkt i Comment-modulen beror på att de används även av andra klasser i mitt Anax-repo. Varje kommentar har en användare kopplad till sig och klassen Comment är därför också beroende av min User-klass. Detta beror på att jag använder Repository för databashantering och för varje foreign key behöver jag ange vilken klass som hanterar den tabell som nyckeln pekar på. Jag skulle gärna försöka lösa detta genom att injecta User-klassen till Comment-klassen, men har ännu inte hittat ett bra tillvägagångssätt.

Det finns alltså en del klasser som behövs för att tester ska kunna köras på modulen. Jag har nu kopierat in dessa klasser i src-mappen i Comment-modulen. Detta är inte alls en lösning jag är nöjd med, men jag kunde i alla fall utesluta dessa extra klasser från att tas med i coverage-rapporten för modulen genom ett tillägg i .phpunit.xml. En framtida lösning skulle kunna vara att lägga upp dessa klasser som egna repon och sedan dra ner dem genom composer i vendor-mappen, men det löser egentligen inte det grundläggande problemet, som jag tror ligger djupt rotat i valet av Repository som databashanterare.

Eftersom Comment-modulen bara består av en CommentController- och en Comment-klass, så finns det rätt så lite som kan testas. De metoder som ligger i kontrollern som är callbacks för olika routrar är inte lämpliga att enhetstesta då de framförallt anropar andra klasser och bygger ihop ett svar på en HTTP-förfrågan, såsom kontroller ska göra i MVC-modellen. Comment-klassen innehåller en enda metod och den lyckas jag testa, samt två av kontrollerns hjälpmetoder. Jag lyckas därmed nå 26 % line coverage, men jag vet inte hur mycket mer jag kan få, i alla fall inte utan att göra seriös refactoring på kommentarsklasserna (vilket iofs kanske skulle behövas).

Sist och slutligen en kort kommentar om att det dyker upp några CodeSniffer-varningar för Comment-modulen på kod som även finns i Anax-repot (det gäller en Form-klass) där all kod passerar validering. Det verkar gälla olika regler i de olika repona, så jag väljer därför att ignorera dessa varningar.

### Några reflektioner över skillnaden med och utan modul?
Genom detta arbete har jag fått ytterligare förståelse för moduler och hur lätt hänt det är att man binder en klass rätt hårt. Jag tror att jag i större framtida projekt definitivt vill använda dessa metoder för att separera moduler från varandra och på det sättet tvinga fram en bättre kodstruktur, som är lättare att uppehålla och byta ut.



Kursmoment 06
-------------

### Har du någon erfarenhet av automatiserade testar och CI sedan tidigare?
Nej, allting som har med C*-flöden är nytt för mig, även om jag stött på begreppen några gånger under årens lopp. Det här med automatiserade tester är intressant, för i detta kursmoment har jag lagt mycket energi på att försöka skriva om koden och lägga till tester för att täcka så mycket som möjligt av koden, så det har inte känts så automatiserat den här veckan. Men nu när det jobbet är gjort så börjar väl det på riktigt automatiserade, att testerna körs varje gång jag gör en ny commit och byggtjänsterna snurrar igång.

### Hur ser du på begreppen, bra, onödigt, nödvändigt, tidskrävande?
C*-flöden är verkligen populärt just nu och hänger väl även ihop med trendbegreppet DevOps. Det är ett helt nytt universum med sina egna begrepp, metoder och verktyg så just nu känns det lite överväldigande att ta in det. Den omfattning som kursmomentet inneburit har dock varit greppbart och intressant. Jag tycker absolut att principen med CI är god och kan leda till bättre organisering och kod. Verktyg som gör kodanalys är också bra att ha till hands. Dock har jag tidigare märkt att när jag haft någon linter aktiv i Atom-miljön och lintern är överdrivet kritisk och listar en massa varningar att jag efter ett tag blir lite färgblind och slutar märka dem. Jag tycker att man inte ska utgå för mycket från kodanalysverktyg, eftersom de inte garanterar att koden är bra och effektiv. Samma sak gäller kodtäckning; har man hög kodtäckning är inte det en garanti för god kod, eftersom iaf PHPUnit verkar räknas utifrån statement coverage och inte exempelvis branch coverage som är en starkare form av coverage. Det blir då upp till en själv om man vill försöka nå detta, för det kommer inte att höja coverage-siffran. Har man istället låg kodtäckning så behöver det inte heller betyda att koden är dålig, utan bara att den är svårtestad, vilket givetvis kan vara ett problem men inte nödvändigtvis något som behöver åtgärdas, vilket jag kommer in på i nästa stycke.

### Hur stor kodtäckning lyckades du uppnå i din modul?
Jag har kämpat med refactoring på min kod men har inte lyckats bättre än att jag nått 32 % coverage. Jag vill ändå påstå att jag inte kan nå bättre täckning än så utan att gå in i de metoder i controllern som hanterar routes direkt och pysslar med redirects och vyer. Att försöka gå in och testa dessa metoder skulle kräva ett oerhört stort jobb med att mocka upp testmiljön. Dessutom så innehåller dessa otestade metoder ganska lite logik utan anropar mest andra moduler och metoder, såsom en god controller ska göra. Att testa dessa metoder skulle jag kategorisera som integrationstest snarare än enhetstest.
Jag har ändå gjort ganska många småjusteringar som jag är nöjd med och separerat olika delar av koden in i egna metoder som jag lyckats testa. Eftersom kodtäckningen inte är så imponerande så har jag istället lagt tid på att öka kodkvalitén enligt de externa verktyg som lagts till, mer om det i nästa stycke. Jag har även till slut förstått hur jag ska hantera de beroenden som mina klasser har när jag gör tester och har mockat upp en del stubbar som behövs för de tester som körs. Detta innebär att det enda externa beroende som finns för att köra tester är till anax/DI.
En sak som bekymrar mig med läget just nu är att nästan alla de metoder som jag just nu lyckas testa egentligen borde göras privata, eftersom de endast anropas inifrån samma klass. Skulle jag göra det så skulle min kodtäckning dock hamna på nära 0%. Därför har jag valt att behålla dem som publika metoder tills vidare.

### Berätta hur det gick att integrera mot de olika externa tjänsterna?
Det gick ganska smidigt. Dock behövde jag göra en del justeringar på grund av uppdateringar som skett sedan detta kursmoment släppts. CircleCI är numera i version 2.0 och deras konfigurationsfil är uppbyggd på ett annat sätt så det blev lite trial&error innan det fungerade som det skulle. Vidare så är PHPUnit 5 numera deprecated så jag behövde uppdatera den till version 6. Den versionen stödjer dock inte längre PHP 5.6 så jag måste uppdatera vilka versioner av PHP som Travis testar för att få grönt därifrån. Bara för att lära mig så valde jag att låta även CodeClimate visa kodtäckningen, vilket jag gjorde genom att koppla ihop den med Travis så att Travis skickar en rapport om kodtäckningen till CodeClimate när den är klar. Jag lade också till SensioLabs men deras tjänst är numera så låst bakom en betalvägg att den analysen inte gav något annat än en badge, jag kan inte se rapporten utan att betala för mig, så den tjänsten lär jag inte fortsätta använda.

### Vilken extern tjänst uppskattade du mest, eller har du förslag på ytterligare externa tjänster att använda?
Jag gillade CodeClimate ganska mycket. Även om den är rätt så snarlik Scrutinizer så tyckte jag att den var lite enklare att använda och ger tydligare rapporter om min kodkvalité, vilket jag uppskattar. Jag lyckades också rätta till en del brister i min kod tack vare den tjänsten och fick upp mitt betyg till ett A, så det är väl klart att man gillar sånt :)



Kursmoment 07/10
-------------

### Krav 1,2,3 - Grunden

Jag har valt att göra en sajt mer inspirerad av Reddit än Stack Overflow. Detta innebär att innehållet är strukturerat mer som diskussiontrådar än frågor och svar. I vissa aspekter har jag försökt göra en noggrannare klon av Reddit, medan andra aspekter är lite mer friform eller mot Stack Overflow-hållet.

Sajten består av en förstasida, en sida för poster, taggar, användare, en about-sida, kontosidor, admin-sidor samt in- och utloggningssidor. Förstasidan visar de senaste posterna, de populäraste taggarna samt de aktivaste användarna. Aktivaste betyder här de som har högst rang.

Post-sidan innehåller en översikt av alla poster, inklusive antal poäng och kommentarer för respektive post, och de kan sorteras enligt datum, poäng eller antal kommentarer. Man kan skapa nya inlägg via denna sida om man är inloggad eller så kan man klicka sig vidare till posternas egna sidor. Där kan man även se och sortera kommentarer, samt lägga till en egen kommentar om man är inloggad. Såväl poster som kommentarer stödjer Markdown-syntax. Är man inloggad och har skrivit någon av kommentarerna eller posten så har man möjlighet att redigera eller radera dem.

Vidare finns sidan Tags som visar de taggar som används, hur många poster som är kopplade till dem, samt kan sortera dem enligt namn eller popularitet. Klickar man på en tagg här eller någon annanstans på sajten så kommer man till en översikt av alla poster som har den taggen kopplad till sig.

På sidan Users kan man se alla registrerade användare och sortera dem enligt namn eller rang, samt klicka sig vidare till deras profiler. Är man inloggad så har man även tillgång till sin egen konto-sida, där man kan ändra detaljer kring sitt konto. Kontobilden är en automatiskt skapad gravatar-bild baserad på ens epostadress. Är man inloggad som admin (inloggning: admin / admin) så har man även en admin-sida (tillgänglig via en länk i footern) där man kan hantera användarkonton. Admin har även möjlighet att redigera och radera alla poster och kommentarer i Post-sektionen av sajten.

Sajten som driftas på studentservern har exempelinnehåll inlagt och där ingår följande konton:
admin / admin
doe / doe
test1 / test1
test2 / test2
test3 / test3
test4 / test4

Till slut finns det en enkel About-sida med länk till repot på Github. Allt är stylat i gräsligt fula färger, för att matcha det tema som sajten handlar om.

Projektet ligger även upplagt på [Github](https://github.com/emsa16/ramverk1-project), tillsammans med enkla instruktioner för hur man installerar projektet på egen hand. Det är rätt enkelt, det mesta av jobbet kring installationen är att sätta upp databasen. Jag har lagt exempelinnehåll i en separat fil, så får man själv välja om man installerar projektet med detta exempelinnehåll eller ej. Repot är även kopplat till Travis och Scrutinizer, där de passerar byggtesterna.


### Krav 4 - Frågor

Eftersom jag valt att skapa en sajt mer lik Reddit än Stack Overflow så funkar det inte riktigt med en funktion att kunna markera svar som accepterade. Istället kör jag mer på Reddits funktion att kunna ge inlägg "guld". Den användare som skapat en post kan välja att "belöna" bra kommentarer till den posten genom att klicka på "reward" under kommentaren. Det dyker då upp en stjärna bredvid posten för att markera dess status, och dessa belönings-badges har en stor påverkan på användarens rang.

Man kan rösta på poster och kommentarer om man är inloggad. För varje post/kommentar så kan en användare ge en röst, upp eller ner. Man kan ändra sin röst eller ta bort den men samma konto kan aldrig ge mer en röst till samma kommentar/post. Såväl poster som kommentarer inuti poster kan sorteras enligt "best", som då visar dem i poängsumme-ordning. Sajten visar också tydligt hur många poäng och kommentarer varje post har.


### Krav 5 - Användare

Varje användare har en öppen profilsida, som alla kan se, även de som inte är inloggade. Profilsidan visar användarens rang samt aktivitet på sidan: poster, kommentarer, alla deras röstningar samt givna och emottagna belönings-badges.

Varje användare har en rang kopplad till sig. Denna visas på profilsidan samt bredvid användarnamnet i varje post eller kommentar. Rangen visar på hur populär och aktiv användaren är. Rangen beräknas på följande sätt: varje mottagen guldstjärna multipliceras med 25, varje röst på en kommentar eller post multipliceras med 5 (inklusive negativa röster) och till slut adderas antalet poster och kommentarer användaren gjort till resultatet. Det är alltså kvalitet över kvantitet som gäller för att få hög rang.


### Allmänt om projektet

Projektet har flutit på väl. Det största problemet har varit att jag varit tvungen att jobba lite grann nu och då, utspritt över en ganska lång tid, så det har varit kämpigt att komma ihåg var man befann sig när man tog upp projektet igen efter en tids frånvaro.

Jag började med att scaffolda fram en grundstomme. Många av de system jag byggt under kursens gång kunde jag återanvända. Användar- och admin-systemet kunde jag använda rakt av från tidigare kursmoment. Däremot så använde jag inte den kommentarsmodul som jag jobbat med under kursens gång. Orsaken till detta är den byggde på en struktur där själva posterna var lagrade i en flatfile-struktur. Detta gjorde den inkompatibel med kraven på att användare ska kunna skapa egna nya poster. Det kändes även annars rimligare att såväl kommentarer som poster skulle ligga i databas och att man då kunde koppla ihop dem med foreign keys. Jag behövde även lägga till stöd för röster och belöningar i kommentarsmodulen, samt ville översätta den till engelska. Allt detta gjorde att jag tog beslutet att inte använda en separat kommentarsmodul, utan integrera koden från min tidigare modul in i detta projekt. Jag kunde ha valt att göra en ny version av min modul, men jag bedömde att det skulle gå snabbare såhär.

Jag valde även att fortsätta använda Repository-modulen som kurskamraten LRC skapat, eftersom den används i min gamla kommentarsmodul. Jag är inte helt nöjd med hur jag använder den i detta projekt. Eftersom jag normaliserat databasen lite grann i och med införandet av röster och belöningar så skulle joins ha suttit bra i databasanropen för att minska antalet anrop och göra processen effektivare. Dock hade jag inte tid att studera denna modul i närmare detalj för att kunna se om detta var möjligt.


### Om kursen

Denna kurs har innehållit en massa koncept på en bred skala. Jag har uppskattat allt det jag lärt mig: djupdykning i PHP, design patterns, ramverksstrukturer såsom MVC, samt koncept som SOLID och DI. Det har varit lite mer teori än tidigare, främst kring olika modeller och sätt att strukturera sin kod. Jag har upplevt att det varit en intressant men ganska utmanande uppgift att försöka jämföra och förstå dessa modeller. De rör sig på så stor skala att jag ofta haft svårt att greppa vad de egentligen innebär. Jag har också uppskattat den genomgående uppgiften genom kursen att skapa ett eget kommentarssystem, nyttigt att lära sig förstå hur de fungerar.

Jag skulle önska mig att kursen gick in mer på design patterns och hjälpte oss att förstå dem och hur man ska tänka kring sådana mer abstrakta koncept. Jag skulle även vilja att vi satte mer tid på att jämföra olika ramverk med varandra, eftersom jag tror att detta kommer att vara en viktig färdighet i yrkeslivet, men jag upplever att det är väldigt svårt att kunna urskilja vilket alternativ man ska välja, när det finns så många aspekter att beakta gällande ramverk. Jag gillade också introt till CI och skulle gärna ha fått mer info kring DevOps-metodologier. Dock förstår jag att allt inte kan rymmas in i en och samma kurs, men just DevOps känns också som något väldigt efterfrågat i dagens arbetsmarknad.

Man kunde plocka bort arbetet med REM-servern och gå direkt på en databas, det kändes som ett onödigt mellansteg och det blev mycket jobb att göra om systemet till att stödja en databas istället i mitten av kursen. Det kan ju också ha varit min approach som ställde till det, då jag valde att köra med ett Repository-mönster för databasen istället för det givna Active Record, vilket gjorde att det tog extra tid.

Jag har uppskattat kursen som helhet och den utmaning den gav mig. Den får 6/10. Tack för denna gång!
