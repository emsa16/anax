---
title: "Redovisningar"
...
Redovisningar
=============

Kursmoment 1
------------

### Gör din egen kunskapsinventering baserat på PHP The Right Way, berätta om dina styrkor och svagheter som du vill förstärka under det kommande året.
Detta var en intressant läsning då man får ett bra helhetsgrepp kring språket och dess olika verktyg och koncept. Den är dock lite ojämnt skriven då vissa sektioner är mycket mer utvecklade än andra, så jag kan inte vara helt säker på att den ger en helt objektivt korrekt överblick. Överlag så fick jag ändå ut mycket av den och jag skulle gärna läsa motsvarande artiklar för andra språk.

Vad kan jag då av detta? Ja, först av allt måste det sägas att även om jag här kommer att klassificera saker som något jag kan, så har jag fortfarande bara två kurser och projekt under bältet inom PHP, så det finns nog inget jag kan fullt ut. Men med det sagt så upplever jag ändå att följande områden behärskar jag någorlunda:

- **OOP**: jag har bra koll på konceptet i två språk nu (PHP och Python) och är bekväm med att programmera i denna paradigm, men det finns fortfarande många avancerade koncept som jag kunde utveckla mig på.
- **databasanvändning och PDO**
- **templates**: det har förekommit i flera kurser, så jag förstår det ganska bra som koncept nu, även om jag inte har koll på alla PHP-specifika template libraries.
- **kodstil**: När jag läser igenom PSR-standarderna så tycker jag att det ganska långt ser ut precis som den kod jag redan skriver.
- **namespaces**

Vad kan jag lite grann men behöver bli bättre på?

- **säkerhet**: jag har bra grunder men vill lära mig mer då detta är ett av de områden som jag funnit mest intressant i studierna.
- **functional programming**: jag vill kunna skapa smartare och mer effektiv kod.
- **tester**: jag kan grunden, men har det inte som en vana och tycker det känns jobbigt att skriva tester. Jag måste lära mig gilla det och lära mig mer avancerade metoder för att kunna testa kod som har dependencies, t.ex. av en databaskoppling.
- **dokumentation**: jag dokumenterar väldigt dåligt just nu och måste lära mig en vana att dokumentera bättre.
- **virtual machines**: vi har använt detta i en tidigare kurs, men jag behöver bli mer van med detta och speciellt bekanta mig med konceptet i PHP-sammanhang, inklusive Vagrant och Docker.
- **dependency injections**: jag kan grunderna, men ser framemot kursens fördjupning i ämnet.
- **dependency management**: jag fattar grunderna.
- **exception handling**: jag använder detta för lite.

Vad kan jag inte alls?

- **designmönster**: vi har bara nosat på det en gång tidigare i Javascript-kursen, men jag ser att flera av kursens referensböcker behandlar det ingående. Jag tycker att det är här programmering börjar bli intressant: olika programmeringsstilar och större konstruktionskoncept som sträcker sig över flera språk
- **build & deployment**: det här är den sista pusselbiten i webbprogrammering som jag upplever att vi inte riktigt gått igenom i någon kurs än så länge
- **continous integration**: jag ser framemot att lära mig om detta i kursen
- **internationalisering**
- **meta programming**: detta är i stort sätt ett helt nytt koncept för mig
- **caching**

Sammanfattningsvis så är de punkter jag främst skulle vilja lära mig och bli bättre på under det kommande året säkerhet, designmönster, deployment och functional programming.

### Vilket blev resultatet från din mini-undersökning om vilka ramverk som för närvarande är mest populära inom PHP (ange källa var du fann informationen)?
Jag kunde inte hitta någon artikel eller presentation av PHP-ramverk som verkade grunda sig på hårda data eller statistik. Jag har därför tittat på fem artiklar som alla påstår sig presentera de mest populära PHP-ramverken just nu, men endast vagt eller inte alls redogör för vad resultatet grundar sig på. Alla artiklar är från sommaren 2017 och hittas på följande länkar:

- [noeticforce.com](http://noeticforce.com/best-php-frameworks-for-modern-web-development)
- [Traversy Media](https://www.youtube.com/watch?v=Q84OlNsOGQY)
- [techjunkie.com](https://www.techjunkie.com/popular-php-frameworks/)
- [Elitech Systems](https://medium.com/@elitechsystems/the-most-popular-php-frameworks-in-2017-a90a1189405e)
- [codementor.io](https://www.codementor.io/sarahallenapp/7-most-popular-php-frameworks-of-2017-b8gyncyvv)

Vad jag gjort är att jag undersökt artiklarna kvantitativt och räknat i hur många av artiklarna ett ramverk nämns. Detta är kanske inte så vetenskapligt gångbart men som en enkel undersökning som ger ett hum om läget just nu så funkar den bra och det är för det mesta samma ramverk som återkommer. Tre ramverk nämns i alla fem artiklar och jag korar därför dem till sommaren 2017s populäraste ramverk:

- Laravel
- Symfony
- CodeIgniter

### Berätta om din syn/erfarenhet generellt kring communities och specifikt communities inom opensource och programmeringsdomänen.
Jag ser både stor potential och stora risker med communities, speciellt sådana som driver utvecklingen av t.ex. ett språk eller en teknik. Potentialen ligger i massans gemensamma intelligens, kapacitet och resurser, samt i den drivkraft som kan råda i ett community med en god kultur där en fin anda råder. Jag gillar också den demokratiska processen i den här typen av grupperingar, som ofta även ackompanjeras av ideella ideologier. Risken ligger dels i att communityt kommer att innehålla många individer som är starkt drivna av sin passion för ämnet, vilket lätt kan leda till konflikter. Och samtidigt som den demokratiska processen är en styrka så är den också en svaghet, då det kan vara svårt att ta effektiva beslut och ena communityt kring något. Eftersom det är frågan om ideellt arbete så finns också risken att gnistan dör, speciellt om communityt saknar eldsjälar. Det är alltså väldigt viktigt att man prioriterar och vårdar communitykulturen.

Jag har endast en utomståendes perspektiv på open source- & programmeringscommunities, då jag än så länge inte deltagit i några projekt, evenemang eller bekantat mig med användargrupper. På basen av videon som anvisades i kursmomentet så gav den dock en ganska mörk bild av PHP-communityt. Föreläsningens syfte var säkert att locka folk men jag kände bara olust att närma mig det communityt, som jag innan föreläsningen inte haft någon särskild uppfattning om. Det verkar som att PHP-communityt är väldigt stort och har lidit av stora problem tidigare, och ärligt talat så känner jag inte idag att jag har någon lust att beblanda mig med dem.

### Vad tror du om begreppet “en ramverkslös värld” som framfördes i videon?
Det är ju intressant att titeln på föreläsningen inte är vad innehållet sist och slutligen föreslår. Föreläsaren föreslår inte en framtid utan ramverk, utan en framtid där man ska kunna jobba mer modulärt och inte känna sig bunden till ett specifikt ramverk och alla dess delar och libraries. Detta kan jag absolut hålla med som en god princip att försöka hålla fast vid, det förvånar mig att det verkar som att många som arbetar med PHP identifierar sig inte som PHP-utvecklare utan t.ex. Laravel-utvecklare. Jag tycker att det finns en fara att köra in sig i ett ramverk för mycket, att man tappar flexibiltet och ett öppet sinne. Tankesättet att jobba modulärt, som är något vi kommer att fokusera på i kursen, ska bli spännande att utforska. Med detta sagt så tycker jag att det låter som en stor utmaning som PHP-FIG försöker lösa genom att skapa standarder för vissa moduler. Detta går dock lite över huvudet på min nuvarande kompetensnivå så jag lämnar det vid detta.

### Hur gick dina förberedelser inför kommentarssystemet?
Jag har inte skrivit någon kod utan endast skissat på papper än så länge. Jag har studerat kommentarsystemet på Stackoverflow och Reddit. Stackoverflow innehåller en del extra funktioner som inte hör till kärnfunktionaliteten för ett kommentarsystem, så jag har fokuserat mer på Reddit. Deras kommentarsystem är ganska enkelt att övergreppa och det finns många sidor som har liknande system, t.ex. Facebook, Twitter och Youtube. Jag har sedan brutit ner kommentarsystemet i mindre delar och planerat hur databasen skulle kunna se ut som ska lagra kommentarerna. Jag är inte säker ännu på hur jag ska strukturera upp det så att jag kan implementera kommentarsavdelningen som ett träd, alltså att man kan kommentera på en kommentar och därmed skapa grenar. Som jag ser det nu så kommer jag att behöva en databas för att lagra användare och kommentarer, en klass för att kommuncera med databasen, en klass för att hantera användare, en klass för sessioner och så en klass för att hantera nya kommentarer och kommentarsröstningar.



Kursmoment 02
-------------

### Allmänna reflektioner:
Jag är lite osäker på hur det är tänkt att vi ska strukturera om vår kod och är inte alls säker på om jag faktiskt delat upp min kod enligt MVC-mönstret. Jag hade tidigare en `Navbar`-klass, men då den endast hade en metod, som för det mesta bestod av HTML så har jag gjort om den till en vy och laddar in navbarens config-fil som data till navbaren direkt i `renderPage`-metoden. Jag har också flyttat ut all kod ur alla routes till en `RouterController`-klass. Denna känns dock lite klumpig och inte särskilt användbar, utan är bara en förflyttning av koden för att passa in i modellen, jag vinner ingenting på det vad jag kan se.

### Vilka tidigare erfarenheter har du av MVC? Använde du någon speciell källa för att läsa på om MVC? Kan du med egna ord förklara någon fördel med kontroller/modell-begreppet, så som du ser på det?
Vi nosade på begreppet i webapp-kursen, då Mithril använde sig MVC-mönstret. Jag skapade dock ingen egentlig förståelse för begreppet då, och såg därför framemot att sätta tänderna i det detta kursmoment. Jag har läst igenom det material som finns i läsanvisningarna flera gånger och har läst flera andra artiklar och ju mer jag läser, desto mer förvirrad blir jag. Det finns väldigt olika sätt att se på MVC-mönstret, så pass olika att jag har svårt att greppa konceptet ens på ett övergripande plan. [Denna artikel](https://blog.codinghorror.com/understanding-model-view-controller/) och [denna](https://www.sitepoint.com/the-mvc-pattern-and-php-1) ger egna versioner som båda skiljer sig väldigt mycket från det jag upplever att Wikipedia-artiklarna beskriver. Till slut fastnar jag för en mycket [kort artikel](https://www.tmprod.com/blog/2012/what-is-mvc-architecture-in-a-web-based-application) från läsanvisningarna i webapp-kursen, som hjälper mig att greppa koncepten på ett sätt som känns användbart.

Utifrån den läsning jag gjort så tolkar jag MVC som följande:

* **Kontroller**: navet i systemet (detta är min uppfattning, på Wikipedia anses modellen vara den centrala delen). Tar emot anrop och ber modellagret att hämta och bearbeta data beroende på anropet. Den behandlade datan skickas sedan till vyn för att läggas in i mallar. Den ifyllda vyn skickas sedan tillbaka till som svar på anropet. Kontrollern är alltså den kod som har kontroll över allt annat. Som jag ser det nu så måste en kontroller i Anax ha tillgång till app-objektet för att den ska kunna ge ordrar till en massa modellklasser. Detta gör dock att kontrollern är ganska hårt bunden till ramverket. Däremot har inte kontrollern så mycket egen logik utan bör vara ganska tunn, i alla fall upplever jag att koden blir bäst uppdelad så mellan kontroller och modell.
* **Modell**: Ett lager som innehåller alla möjliga typer av klasser, dels för att skapa kontakt med databaser och dels för att hantera data enligt kontrollerns order. Modellen är den som gör grovjobbet och har det mesta av logiken, men inte så mycket egen makt eller information om systemet på en global nivå. Jag tänker att modelllagret helst inte ska ha tillgång till app-objektet, framförallt för att modeller ska kunna göras modulära.
* **Vy**: tar emot data från kontrollern, lägger in den i HTML-mallar och bygger själva sidan. Vyn skickar därefter tillbaka den färdiga sidan till kontrollern.

Den här uppdelningen gör kontrollern till en ganska ointressant del, då den endast kallas andra metoder och funktioner, men det är kanske detta som är meningen. Dock har jag svårt att se var gränsen går mellan kontroller och modell, eftersom exempelvis Wikipedia-artiklarna mest fokuserar på separationen av vy och logik, vilket jag mycket väl förstår syftet med. I vissa artiklar omnämns kontrollern som att dess uppgift är att ha hand om input-logik, men jag tycker att det vore att förminska dess roll, i alla fall enligt det sätt jag ser på MVC.

Just nu ser jag den främsta fördelen med MVC att man kan göra modellklasserna löst kopplade och modulära. Jag tror också att en välbyggd MVC-applikation borde vara lätt att överse och underhålla.

### Kom du fram till vad begreppet SOLID innebar och vilka källor använde du? Kan du förklara SOLID på ett par rader med dina egna ord?
Jag har spenderat så mycket tid med att förstå MVC att SOLID-begreppet inte blivit så grundligt studerat. Jag har endast använt mig av kursmomentets anvisade material att förstå SOLID. På ett väldigt ytligt plan så är SOLID en samling designprinciper för objektorienterad design. Syftet med SOLID är att göra koden enklare att bygga, förstå och underhålla. Jag tycker att SOLID verkar som en väldigt viktig principsamling också när man vill göra sin kod så modulär som möjligt. Jag tycker att konceptet låter bra och intressant och jag ser framemot att kunna implementera det så snart som möjligt. Än så länge så är det dock väldigt svårt att minnas de enskilda principerna och även att förstå hur de konkret appliceras.

### Gick arbetet med REM servern bra och du lyckades integrera den i din me-sida?
Det gick väldigt enkelt att komma igång med REM-servern och att lyfta in den i me-sidan. Jag har gått den första versionen av webapp-kursen, så för mig är detta med REM-server helt nytt. Jag förstår inte riktigt varför det vi använder här kallas för REM-server. Jag hittar ingen information på nätet om det, förutom den tjänst som länkas till, men den tjänsten används ju inte i detta sammanhang. Jag blir också fundersam när jag ser `RemController` och `RemServer`, detta antyder att varje modellklass ska ha en egen kontrollerklass. Samtidigt rekommenderas man hålla kontrollerklassen liten. Hur många kontrollers är det tänkt man ska ha och hur delar man upp dem? Detta förblir oklart för mig, även om jag inte har svårt att använda systemen.

### Berätta om arbetet med din kommentarsmodul, hur långt har du kommit och hur tänker du?
Detta skulle vara en första prototyp och visst är det mycket funktionalitet som jag valt bort i detta skede, men särskilt enkelt blev det ändå inte. Det var mycket att fixa och fundera på. Jag har tittat mycket på [Hacker News](https://news.ycombinator.com/item?id=15254952) kommentarssystem, då deras gränssnitt är avskalat och fokuserat. Jag har lagt upp två inlägg som har ett kommentarssystem kopplat till sig. Kommentarerna är ordnade hierarkiskt så att en kommentar kan få egna svar och därmed skapar en förgrening. Jag har den underliggande strukturen för att implementera ett poängröstningssystem men har valt bort att implementera möjligheten att rösta i detta skede. En default-uppsättning med kommentarer ligger i en json-fil, som kan nås och bearbetas med REM-servern.

Jag har skapat en `Comment`-klass och en `CommentController`-klass för att hantera kommentarssystemet. I enlighet med mina tankar om MVC så ligger minimalt med logik i kontrollern, den anropar istället andra klasser och får tillbaka värden som sedan skickas vidare i nästa steg. I modellklassen ligger alla metoder som hanterar olika skeden av kommentarshanteringen. Vissa metoder är lite väl stora och kan förhoppnningsvis refaktoreras. Dessutom så hamnar en massa HTML-kod i modellen när jag bygger själva kommentarssektionen. Borde jag försöka lyfta ut detta i vyer? Det är tänkbart, men isåfall behöver jag kanske gå en annan väg än via `View`-modulen? En annan sak jag tvekar om är huruvida jag bör splitta upp koden i fler metoder för att göra dem tydligare och mer specifika, enligt single responsibility-principen, eller om jag bör försöka hålla koden så DRY som möjligt. Jag har gått fram och tillbaka mellan dessa under arbetets gång. Just nu känns framförallt metoden `buildCommentSection()` alltför stor och generell, men om jag bryter upp den i flera metoder så finns risken att jag upprepar mig, som är fallet lite grann med metoderna `buildNewCommentBox()` och `buildEditCommentBox()`.



Kursmoment 03
-------------

### Hur känns det att jobba med begreppen kring dependency injection, service locator och lazy loading?
De nya begreppen som introducerades detta kursmoment är ganska självförklarande och därför ganska lätta att ta till sig. Just på me-sidan kanske inte lazy loading har så stor betydelse men jag gillar konceptet. Det känns som en väldigt bra princip att inte ladda in något i onödan. Nu syns ju vilka paket man laddar in bara på `debug/info`-sidan, så variationen mellan vilka moduler som laddas in på olika sidor blir inte så visualiserad, men vetskapen om att så sker är rogivande. DI-begreppet innebär en klar förbättring av strukturen och gör delarna mer modulära och självständiga än tidigare.
Service locator-begreppet har jag dock lite svårare att greppa. Det verkar så likt dependency injection container att jag först tänker att det är samma sak, men vid mer efterforskning så verkar de vara två olika lösningar på samma problem, och service locator verkar även anses som ett dåligt mönster. Vad jag lyckats uttyda så verkar service locator innebära att klassen är beroende av denna service container, medan dependency injection innebär att beroenden skickas in till klassen helt och hållet utifrån så att klassen inte behöver veta något om detta.

### Hur känns det att göra dig av med beroendet till $app, blir $id bättre?
Jag tycker att koden blir redigare och bättre strukturerad med $di. Skillnaden är kanske inte direkt stor i och med att jag mest bara flyttat över $app-konceptet till $di. Jag uppskattar ändå config-filen di.php, då den är mycket mer överskådlig än den gamla service.php.

### Hur känns det att återigen göra refaktoring på din me-sida, blir det förbättringar på kodstrukturen, eller bara annorlunda?
Det var inte så omfattande arbete denna gång att refaktorera om till en sida med di-konstruktion. I mina egna klasser har jag bara bytt app mot di tack vare att jag använder mig av InjectionMagicTrait så att jag inte behöver ändra `$this->di->request` till `$this->di->get(”request”);`. Även om den senare tydligare visar att jag använder en di-konstruktion nu så är den förra mer lättläslig. Det nya sättet att skriva routes känns också tydligare. Istället för att ha allting i routen på en rad har de nya route-filerna en tydlig struktur genom arrayer med bestämda nyckelvärden. På det hela taget tycker jag att denna omgång av refaktorering kändes bra då den med små medel förtydligade mycket.

### Lyckades du införa begreppen kring DI när du vidareutvecklade ditt kommentarssystem?
Jag tror att jag infört begreppen kring DI i mitt kommentarssystem, men är lite osäker på vad omfattningen av DI kan innebära för mina klasser. Som jag nämnde ovan så bytte jag bara ut app mot di i min kontroller-klass. Min modellklass för kommentarssystemet har sedan tidigare ingen vetskap om $di, utan jag skickar in eventuella moduler som behövs genom argument direkt i metodanropet till modellklassen.

### Påbörjade du arbetet (hur gick det) med databasmodellen eller avvaktar du till kommande kmom?
Jag väljer att avvakta med databasen, eftersom jag inte vill börja fixa på en lösning om det ändå kommer att komma ytterligare instruktioner i nästa kursmoment. Jag har inte heller gjort så mycket mer på den nuvarande lösningen där jag sparar kommentarerna genom remservern, eftersom det ändå bara är en mockup inför den stundande databas-implementationen.

Jag har istället valt att lägga till en del småfunktionalitet som prioriterats bort i förra kursmomentet. Det går nu att sortera kommentarerna efter flest poäng, nyaste eller äldsta. Trädstrukturen följer sorteringsmetoden, i stil med Reddit. Sidan sorterar automatiskt på de bästa kommentarerna, vilket kanske inte blir så tydligt när mängden kommentarer är små, men får stor effekt på hur man kan följa intressanta kommentarskedjor när det finns många kommentarer och många som röstat.

Jag har även lagt in gränssnitt och funktionalitet för att kunna rösta upp och ner kommentarer. Eftersom det just nu inte finns användare implementerade så är möjligheten att rösta obegränsad. Vidare har jag ändrat beteendet för raderade kommentarer, istället för att ta bort dem rakt av så markeras kommentaren med en radera-flagga i systemet och texten syns inte i kommentarsfältet men noden blir kvar i hierarkin, istället för att hela den underliggande kedjan skulle tas bort tillsammans med den kommentar som raderas. Gränssnittet visar nu även när en kommentar senast redigerats. Tiden när en kommentar lagts till visar nu istället för ett datum en sträng i stilen ’x minuter sedan’.

`buildCommentSection`-metoden är fortfarande för stor och komplex, och validatorn har även klagat över cyclomatic complexity som stigit för högt i den. Jag har temporärt fixat detta med att ganska godtyckligt lyfta över en del kod i separata metoder, men det är inte gjort på ett bra sätt, så jag vill ännu justera detta.

### Allmänna kommentare kring din me-sida och dess kodstruktur?
Jag har nu valt att använda `\Anax\Page\PageRender()`-klassen i mitt ramverk, såsom artiklarna gjort. Detta är det mest logiska att använda när jag nu har modulen Page med och använder den i övrigt i mina routes. Dock kräver det att jag går in och justerar i `renderPage`-metoden för att få med header, navbar och footer. Detta känns inte så kul när denna klass ligger i min vendor-mapp och jag inte riktigt tycker om att gå in och ändra där. Det jag eventuellt kommer att göra är att återgå till att använda `renderPage`-metoden i min app-klass, eftersom den ligger i min egen src-mapp, och då känns det ok att rota mer i koden. Vi får se.



Kursmoment 04
-------------

Kursmoment 05
-------------

Kursmoment 06
-------------

Kursmoment 07/10
-------------
